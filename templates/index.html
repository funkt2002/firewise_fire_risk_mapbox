<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fire Risk Calculator</title>
    <script src='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css' rel='stylesheet' />
    <script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.0/mapbox-gl-draw.js'></script>
    <link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.0/mapbox-gl-draw.css' type='text/css' />
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <script src="{{ url_for('static', filename='welcome-popup.js') }}"></script>
    <script src="{{ url_for('static', filename='js/client-filtering.js') }}"></script>
    <script src="{{ url_for('static', filename='js/client-scoring.js') }}"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        
        #map { 
            position: absolute; 
            top: 0; 
            bottom: 0; 
            width: 100%; 
        }
        
        /* Main control panel */
        .control-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(26, 26, 26, 0.95);
            padding: 15px;
            border-radius: 4px;
            width: 320px;
            max-height: calc(100vh - 60px);
            overflow-y: auto;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        .control-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        .control-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .control-panel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }
        
        h1 {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 15px;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .help-btn {
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s;
        }
        
        .help-btn:hover {
            background: #45a049;
        }
        
        h2 {
            font-size: 13px;
            font-weight: 600;
            color: #fff;
            margin: 15px 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Section styling */
        .control-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        /* Slider styling */
        .slider-container {
            margin: 12px 0;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ccc;
        }

        .exclude-weight {
            margin-left: 8px;
            accent-color: #ff6666;
        }
        
        .slider-value {
            color: #fff;
            font-weight: 500;
            min-width: 45px;
            text-align: right;
        }
        
        .slider {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            outline: none;
            cursor: pointer;
            border-radius: 2px;
            margin: 8px 0;
        }
        
        .slider::-webkit-slider-track {
            width: 100%;
            height: 4px;
            border-radius: 2px;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }
        
        .slider::-moz-range-track {
            width: 100%;
            height: 4px;
            border-radius: 2px;
        }
        
        .slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #fff;
            cursor: pointer;
            border-radius: 50%;
            border: none;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
        }
        
        .slider::-moz-range-thumb:hover {
            transform: scale(1.2);
        }
        
        .slider::-moz-range-progress {
            background: #4a90e2;
            height: 4px;
            border-radius: 2px;
        }
        
        /* Toggle/Checkbox styling */
        .toggle-container {
            margin: 8px 0;
        }
        
        .toggle-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 12px;
            color: #ccc;
            padding: 4px 0;
        }
        
        .toggle-label:hover {
            color: #fff;
        }
        
        .toggle-label input[type="checkbox"],
        .toggle-label input[type="radio"] {
            width: 14px;
            height: 14px;
            margin-right: 8px;
            cursor: pointer;
            accent-color: #4CAF50;
        }
        
        /* Button styling */
        .button {
            background: #333;
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            text-align: center;
            font-size: 12px;
            cursor: pointer;
            border-radius: 3px;
            width: 100%;
            transition: all 0.2s;
            margin: 4px 0;
        }
        
        .button:hover:not(:disabled) {
            background: #444;
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .button.primary {
            background: #4CAF50;
            border-color: #4CAF50;
        }
        
        .button.primary:hover:not(:disabled) {
            background: #45a049;
            border-color: #45a049;
        }

        .button.small {
            padding: 4px 8px;
            font-size: 10px;
            font-weight: 500;
        }
        
        /* Input styling */
        .input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
        }
        
        .input-group label {
            font-size: 12px;
            color: #ccc;
            flex: 1;
        }
        
        .number-input {
            width: 80px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            color: #fff;
            font-size: 12px;
        }
        
        .number-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.4);
            background: rgba(255, 255, 255, 0.15);
        }
        
        /* Stats display */
        .stats {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 3px;
            font-size: 11px;
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .stats-row {
            display: flex;
            justify-content: space-between;
            color: #aaa;
        }
        
        .stats-value {
            color: #fff;
            font-weight: 500;
        }
        
        /* Legend styling */
        .legend {
            position: absolute;
            bottom: 20px;
            right: 10px;
            background: rgba(26, 26, 26, 0.95);
            padding: 12px;
            border-radius: 4px;
            font-size: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        .legend-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #fff;
        }
        
        .legend-gradient {
            height: 15px;
            background: linear-gradient(to right, #ffffff 0%, #ffcccc 25%, #ff6666 50%, #ff0000 75%, #990000 100%);
            border-radius: 2px;
            margin: 8px 0;
        }
        
        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #aaa;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 11px;
            color: #ccc;
        }
        
        .legend-box {
            width: 16px;
            height: 3px;
            margin-right: 8px;
            border: 2px solid #0066ff;
            border-radius: 1px;
        }
        

        
        /* Popup styling */
        .mapboxgl-popup-content {
            background: rgba(26, 26, 26, 0.95);
            color: #e0e0e0;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        .mapboxgl-popup-content h3 {
            margin: 0 0 8px 0;
            font-size: 13px;
            color: #fff;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 5px;
        }
        
        .mapboxgl-popup-content p {
            margin: 3px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .mapboxgl-popup-content strong {
            color: #aaa;
            font-weight: normal;
        }
        
        .mapboxgl-popup-close-button {
            color: #fff;
            font-size: 16px;
            padding: 4px 8px;
        }
        
        .mapboxgl-popup-close-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .mapboxgl-popup-anchor-top .mapboxgl-popup-tip {
            border-bottom-color: rgba(26, 26, 26, 0.95);
        }
        
        /* Add spinner styles */
        .spinner-container {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #4a90e2;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        .spinner-text {
            color: #4a90e2;
            margin-top: 10px;
            text-align: center;
            font-size: 14px;
            font-weight: 500;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Distribution plot button styling */
        .dist-button {
            background: #444;
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            border-radius: 3px;
            margin: 2px;
            transition: all 0.2s;
        }
        
        .dist-button:hover {
            background: #555;
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .dist-buttons {
            display: flex;
            justify-content: flex-end;
            margin-top: 4px;
        }
        
        /* Modal styling */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
        }
        
        .modal-content {
            background-color: #1a1a1a;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.2);
            width: 80%;
            max-width: 800px;
            border-radius: 4px;
        }
        
        .close-modal {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close-modal:hover {
            color: #fff;
        }
        
        /* Measure tool styling */
        .measure-container {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1;
            background: rgba(26, 26, 26, 0.95);
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .distance-container {
            color: #fff;
            font-size: 12px;
            line-height: 18px;
            margin: 0;
            padding: 5px 10px;
            border-radius: 3px;
        }

        .filter-group {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .filter-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            min-width: 150px;
        }

        .filter-group select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
            background-color: #fff;
            color: #333;
        }

        .filter-group select:disabled {
            background-color: #f5f5f5;
            color: #999;
        }

        .slider.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <!-- Add spinner HTML -->
    <div class="spinner-container" id="spinner">
        <div class="spinner"></div>
        <div class="spinner-text">Calculating...</div>
    </div>
    
    <div class="control-panel">
        <h1>Fire Risk Calculator <button class="help-btn" onclick="WelcomePopup.showWelcome()" title="Show Tutorial">?</button></h1>
        
        <div class="control-section">
            <h2>Risk Factor Weights</h2>
            <div id="weight-sliders">
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Number of Structures Within Window (1/4 mile)</span>
                        <span class="slider-value" id="qtrmi_s-value">30%</span>
                    </div>
                    <input type="range" class="slider weight-slider" id="qtrmi_s" min="0" max="100" value="30">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Distance to Nearest Neighbor</span>
                        <span class="slider-value" id="neigh1d_s-value">0%</span>
                    </div>
                    <div style="font-size: 10px; color: #888; margin-bottom: 3px;">Only Includes Parcels with Structure Data</div>
                    <input type="range" class="slider weight-slider" id="neigh1d_s" min="0" max="100" value="0">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>WUI coverage percentage (1/2 mile)</span>
                        <span class="slider-value" id="hwui_s-value">10%</span>
                    </div>
                    <input type="range" class="slider weight-slider" id="hwui_s" min="0" max="100" value="10">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Very High Fire Hazard Zone coverage (1/2 mile)</span>
                        <span class="slider-value" id="hvhsz_s-value">30%</span>
                    </div>
                    <input type="range" class="slider weight-slider" id="hvhsz_s" min="0" max="100" value="30">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Agricultural Coverage (1/2 Mile)</span>
                        <span class="slider-value" id="hagri_s-value">11%</span>
                    </div>
                    <input type="range" class="slider weight-slider" id="hagri_s" min="0" max="100" value="11">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Fuel Break coverage (1/2 mile)</span>
                        <span class="slider-value" id="hfb_s-value">10%</span>
                    </div>
                    <input type="range" class="slider weight-slider" id="hfb_s" min="0" max="100" value="10">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Mean Parcel Slope</span>
                        <span class="slider-value" id="slope_s-value">0%</span>
                    </div>
                    <input type="range" class="slider weight-slider" id="slope_s" min="0" max="100" value="0">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Burn Scar Coverage (1/2 mile)</span>
                        <span class="slider-value" id="hbrn_s-value">9%</span>
                    </div>
                    <input type="range" class="slider weight-slider" id="hbrn_s" min="0" max="100" value="9">
                </div>
                <div style="text-align: right; margin-top: 5px;">
                    <span style="font-size: 11px; color: #888;">Max Parcels: <span id="max-parcels-value">500</span></span>
                </div>
            </div>
        </div>
        
        <div class="control-section">
            <h2>Budget Settings</h2>
            <div class="input-group">
                <label>Budget ($)</label>
                <input type="number" class="number-input" id="budget" value="500000" min="0" step="10000">
            </div>
            <div class="input-group">
                <label>Cost/Parcel ($)</label>
                <input type="number" class="number-input" id="cost-per-parcel" value="1000" min="0" step="100">
            </div>
            <div class="input-group">
                <label>Max Parcels</label>
                <input type="number" class="number-input" id="max-parcels" value="500" min="1" max="5000">
            </div>
            <button class="button primary" id="calculate-btn">Calculate</button>
            <button class="button" id="score-distribution-btn" style="margin-top: 8px;">Calculated Risk Score Distribution</button>
        </div>

        <div class="control-section">
            <h2>Weight Inference</h2>
            <p style="font-size: 11px; color: #aaa; margin-bottom: 10px;">Draw multiple areas to optimize weights for combined selection</p>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                <button class="button" id="draw-rectangle">Add Rectangle</button>
                <button class="button" id="draw-lasso">Add Lasso</button>
            </div>
            <div style="margin: 8px 0; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 3px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                    <span style="font-size: 11px; color: #aaa;">Selection Areas:</span>
                    <span style="font-size: 11px; color: #fff;" id="selection-count">0</span>
                </div>
                <div style="display: flex; gap: 5px;">
                    <button class="button small" id="clear-last-selection" disabled>Remove Last</button>
                    <button class="button small" id="clear-all-selections" disabled>Clear All</button>
                </div>
            </div>
            <button class="button" id="infer-weights" disabled>Infer Weights from Multi-Selection</button>
            <button class="button" id="download-lp-btn" disabled>Download .LP File</button>
            <button class="button" id="view-solution-btn" disabled>View Solution Report</button>
            <p style="font-size: 10px; color: #888; margin: 5px 0;">↑ Maximizes total risk score across all selected areas</p>
            
            <div style="margin-top: 15px; border-top: 1px solid #444; padding-top: 10px;">
                <h3 style="font-size: 12px; color: #aaa; margin-bottom: 8px;">Exclude Variables from Scoring & Weight Inference:</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size: 11px;">
                    <div class="toggle-container">
                        <label class="toggle-label">
                            <input type="checkbox" class="exclude-weight" id="exclude-qtrmi_s" title="Exclude from calculation">
                            Quarter Mile Incidents
                        </label>
                    </div>
                    <div class="toggle-container">
                        <label class="toggle-label">
                            <input type="checkbox" class="exclude-weight" id="exclude-neigh1d_s" title="Exclude from calculation">
                            Nearest Neighbor Distance
                        </label>
                    </div>
                    <div class="toggle-container">
                        <label class="toggle-label">
                            <input type="checkbox" class="exclude-weight" id="exclude-hwui_s" title="Exclude from calculation">
                            WUI Coverage
                        </label>
                    </div>
                    <div class="toggle-container">
                        <label class="toggle-label">
                            <input type="checkbox" class="exclude-weight" id="exclude-hvhsz_s" title="Exclude from calculation">
                            Fire Hazard Zone Coverage
                        </label>
                    </div>
                    <div class="toggle-container">
                        <label class="toggle-label">
                            <input type="checkbox" class="exclude-weight" id="exclude-hagri_s" title="Exclude from calculation">
                            Agricultural Coverage
                        </label>
                    </div>
                    <div class="toggle-container">
                        <label class="toggle-label">
                            <input type="checkbox" class="exclude-weight" id="exclude-hfb_s" title="Exclude from calculation">
                            Fuel Break Coverage
                        </label>
                    </div>
                    <div class="toggle-container">
                        <label class="toggle-label">
                            <input type="checkbox" class="exclude-weight" id="exclude-slope_s" title="Exclude from calculation">
                            Mean Parcel Slope
                        </label>
                    </div>
                    <div class="toggle-container">
                        <label class="toggle-label">
                            <input type="checkbox" class="exclude-weight" id="exclude-hbrn_s" title="Exclude from calculation">
                            Burn Scar Coverage
                        </label>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="control-section">
            <h2>Results</h2>
            <div class="stats">
                <div class="stats-row">
                    <span>Total Parcels:</span>
                    <span class="stats-value" id="total-parcels">56308</span>
                </div>
                <div class="stats-row">
                    <span>Selected:</span>
                    <span class="stats-value" id="selected-parcels">500</span>
                </div>
                <div class="stats-row">
                    <span>Total Risk:</span>
                    <span class="stats-value" id="total-risk">408.88</span>
                </div>
                <div class="stats-row">
                    <span>Avg Risk:</span>
                    <span class="stats-value" id="avg-risk">0.82</span>
                </div>
                <div class="stats-row" id="normalization-row" style="display: none;">
                    <span>Normalization:</span>
                    <span class="stats-value" id="normalization-mode">Global</span>
                </div>
            </div>
            <button class="button" id="export-shapefile">Export Shapefile</button>
        </div>
        
        <div class="control-section">
            <h2>Filters</h2>
            <div style="margin-bottom: 15px;">
                <h3 style="font-size: 12px; color: #aaa; margin-bottom: 8px;">Score Type:</h3>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="radio" name="score-type" id="use-basic-scores" value="basic" checked>
                        Basic Min-Max Scores
                    </label>
                </div>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="radio" name="score-type" id="use-quantiled-scores" value="quantiled">
                        Robust Min-Max Scores
                    </label>
                </div>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="radio" name="score-type" id="use-quantile" value="quantile">
                        Quantile Scores
                    </label>
                </div>
            </div>
            
            <div style="margin-bottom: 15px;">
                <h3 style="font-size: 12px; color: #aaa; margin-bottom: 8px;">Normalization:</h3>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" id="use-local-normalization" checked>
                        Renormalize scores for filtered data
                    </label>
                </div>
                <div id="local-norm-info" style="font-size: 11px; color: #888; margin-top: 4px; display: none;">
                    <div id="local-norm-status"></div>
                </div>
            </div>
            
            <div style="margin-bottom: 15px;">
                <h3 style="font-size: 12px; color: #aaa; margin-bottom: 8px;">Exclude parcels without:</h3>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" id="filter-wui-min30-enabled">
                        WUI Coverage
                    </label>
                </div>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" id="filter-vhsz-min10-enabled">
                        Fire Hazards Coverage
                    </label>
                </div>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" id="filter-brns-enabled">
                        No Burn Scars
                    </label>
                </div>


            </div>

            <div>
                <h3 style="font-size: 12px; color: #aaa; margin-bottom: 8px;">Filter Parcels out based on:</h3>
                <div class="input-group" style="display: flex; align-items: center; margin-bottom: 8px; font-size: 12px;">
                    <input type="checkbox" id="filter-yearbuilt-enabled" style="margin-right: 8px; vertical-align: middle;">
                    <span style="white-space: nowrap; vertical-align: middle;">Built after year:</span>
                    <input type="number" class="number-input" id="filter-yearbuilt" min="1800" max="2024" value="1996" style="margin-left: 8px; width: 80px; vertical-align: middle;">
                </div>
                <div class="toggle-container" style="margin-left: 20px; margin-bottom: 8px;">
                    <label class="toggle-label">
                        <input type="checkbox" id="filter-yearbuilt-exclude-unknown">
                        Exclude Unknown Year Built
                    </label>
                </div>
                <div class="input-group" style="display: flex; align-items: center; margin-bottom: 8px; font-size: 12px;">
                    <input type="checkbox" id="filter-strcnt-enabled" style="margin-right: 8px; vertical-align: middle;">
                    <span style="white-space: nowrap; vertical-align: middle;">Minimum Number of Structures</span>
                    <input type="number" class="number-input" id="filter-strcnt" value="1" min="0" style="margin-left: 8px; width: 80px; vertical-align: middle;">
                </div>
                <div class="input-group" style="display: flex; align-items: center; margin-bottom: 8px; font-size: 12px;">
                    <input type="checkbox" id="filter-neigh1d-enabled" style="margin-right: 8px; vertical-align: middle;">
                    <span style="white-space: nowrap; vertical-align: middle;">Nearest neighboring structure distance</span>
                    <input type="number" class="number-input" id="filter-neigh1d" min="0" max="1000" value="50" style="margin-left: 8px; width: 80px; vertical-align: middle;">
                </div>
            </div>

            <div class="input-group" id="aspect-exclude-list" style="display: flex; flex-direction: column; align-items: flex-start; margin-top: 8px; font-size: 12px;">
                <label style="font-weight: bold; margin-bottom: 4px;">Exclude Aspect Directions</label>
                <div style="display: flex; flex-direction: row; gap: 18px; justify-content: flex-start; width: 100%;">
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <input type="checkbox" class="aspect-exclude" id="aspect-N" value="N" style="vertical-align: middle;">
                        <label for="aspect-N" style="font-size: 11px; color: #ccc; margin-top: 2px;">N</label>
                    </div>
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <input type="checkbox" class="aspect-exclude" id="aspect-NE" value="NE" style="vertical-align: middle;">
                        <label for="aspect-NE" style="font-size: 11px; color: #ccc; margin-top: 2px;">NE</label>
                    </div>
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <input type="checkbox" class="aspect-exclude" id="aspect-E" value="E" style="vertical-align: middle;">
                        <label for="aspect-E" style="font-size: 11px; color: #ccc; margin-top: 2px;">E</label>
                    </div>
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <input type="checkbox" class="aspect-exclude" id="aspect-SE" value="SE" style="vertical-align: middle;">
                        <label for="aspect-SE" style="font-size: 11px; color: #ccc; margin-top: 2px;">SE</label>
                    </div>
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <input type="checkbox" class="aspect-exclude" id="aspect-S" value="S" style="vertical-align: middle;">
                        <label for="aspect-S" style="font-size: 11px; color: #ccc; margin-top: 2px;">S</label>
                    </div>
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <input type="checkbox" class="aspect-exclude" id="aspect-SW" value="SW" style="vertical-align: middle;">
                        <label for="aspect-SW" style="font-size: 11px; color: #ccc; margin-top: 2px;">SW</label>
                    </div>
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <input type="checkbox" class="aspect-exclude" id="aspect-W" value="W" style="vertical-align: middle;">
                        <label for="aspect-W" style="font-size: 11px; color: #ccc; margin-top: 2px;">W</label>
                    </div>
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <input type="checkbox" class="aspect-exclude" id="aspect-NW" value="NW" style="vertical-align: middle;">
                        <label for="aspect-NW" style="font-size: 11px; color: #ccc; margin-top: 2px;">NW</label>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="control-section">
            <h2>Spatial Filter</h2>
            <p style="font-size: 11px; color: #aaa; margin-bottom: 10px;">Draw an area to only show parcels within that boundary</p>
            <button class="button" id="subset-rectangle">Draw Rectangle</button>
            <button class="button" id="subset-lasso">Draw Lasso</button>
            <button class="button" id="clear-subset">Clear Filter</button>
            <button class="button primary" id="filter-parcels" disabled>Filter Parcels</button>
            <div id="subset-indicator" style="font-size: 11px; color: #4CAF50; margin-top: 8px; display: none;">
                ✓ Spatial filter active
            </div>
        </div>
        
        <div class="control-section">
            <h2>Map Layers</h2>
            <div class="toggle-container">
                <label class="toggle-label">
                    <input type="checkbox" class="layer-toggle" data-layer="parcels" checked>
                    Parcels
                </label>
            </div>
            <div class="toggle-container" style="margin-left: 20px; margin-bottom: 10px;">
                <label class="toggle-label" style="font-size: 12px; color: #ccc;">
                    Opacity:
                    <input type="range" id="parcels-opacity" min="0" max="100" value="80" style="width: 100px; margin-left: 8px;">
                </label>
            </div>
            <div class="toggle-container">
                <label class="toggle-label">
                    <input type="checkbox" class="layer-toggle" data-layer="agricultural">
                    Agriculture
                </label>
            </div>
            <div class="toggle-container">
                <label class="toggle-label">
                    <input type="checkbox" class="layer-toggle" data-layer="fuelbreaks">
                    Fuel Breaks
                </label>
            </div>
            <div class="toggle-container">
                <label class="toggle-label">
                    <input type="checkbox" class="layer-toggle" data-layer="wui">
                    WUI Zone
                </label>
            </div>
            <div class="toggle-container">
                <label class="toggle-label">
                    <input type="checkbox" class="layer-toggle" data-layer="hazard">
                    Very High Hazard Zone
                </label> 
            </div>
            <div class="toggle-container">
                <label class="toggle-label">
                    <input type="checkbox" class="layer-toggle" data-layer="structures">
                    Structures
                </label>
            </div>
            <div class="toggle-container">
                <label class="toggle-label">
                    <input type="checkbox" class="layer-toggle" data-layer="firewise">
                    Firewise Communities
                </label>
            </div>
            <div class="toggle-container">
                <label class="toggle-label">
                    <input type="checkbox" class="layer-toggle" data-layer="burnscars">
                    Burn Scars
                </label>
            </div>
            <h3 style="font-size: 12px; color: #aaa; margin: 15px 0 5px 0;">Base Layers</h3>
            <div class="toggle-container">
                <label class="toggle-label">
                    <input type="checkbox" class="layer-toggle" data-layer="dark" checked>
                    Dark
                </label>
            </div>
            <div class="toggle-container">
                <label class="toggle-label">
                    <input type="checkbox" class="layer-toggle" data-layer="light">
                    Light
                </label>
            </div> 
            <div class="toggle-container">
                <label class="toggle-label">
                    <input type="checkbox" class="layer-toggle" data-layer="satellite">
                    Satellite
                </label>
            </div>
        </div>
    </div>
    
    <!-- Add measure tool container -->
    <div id="measure-container" class="measure-container">
        <div id="distance" class="distance-container"></div>
    </div>

    <div class="legend">
        <div class="legend-title">Fire Risk</div>
        <div class="legend-gradient"></div>
        <div class="legend-labels">
            <span>0.00</span>
            <span>1.00</span>
        </div>
        <div class="legend-item" style="margin-top: 10px;">
            <div class="legend-box"></div>
            <span>Selected for Treatment</span>
        </div>
    </div>

    <!-- Add modal for distribution plots -->
    <div id="dist-modal" class="modal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <div id="dist-plot"></div>
        </div>
    </div>

    <!-- Solution Report Modal -->
    <div id="solution-modal" class="modal">
        <div class="modal-content" style="max-width: 95%; width: 1200px; max-height: 90vh;">
            <span class="close-modal" id="close-solution-modal">&times;</span>
            <h2 style="margin: 0 0 15px 0; color: #fff; font-size: 18px;">Infer Weights Solution</h2>
            <pre id="solution-text" style="
                white-space: pre-wrap; 
                font-family: 'Courier New', monospace; 
                font-size: 11px; 
                line-height: 1.4; 
                max-height: 70vh; 
                overflow-y: auto; 
                background: #2a2a2a; 
                padding: 15px; 
                border-radius: 4px; 
                color: #e0e0e0;
                margin: 0;
                border: 1px solid rgba(255,255,255,0.2);
            "></pre>
        </div>
    </div>

    <script>
        // Custom rectangle drawing mode
        const DrawRectangle = {
            onSetup(opts) {
                const rectangle = this.newFeature({
                    type: 'Feature',
                    properties: {},
                    geometry: {
                        type: 'Polygon',
                        coordinates: [[]]
                    }
                });
                this.addFeature(rectangle);
                this.clearSelectedFeatures();
                this.map.doubleClickZoom.disable();
                this.updateUIClasses({ mouse: 'add' });
                this.setActionableState({ trash: true });
                return { rectangle, startPoint: null };
            },
            onClick(state, e) {
                if (!state.startPoint) {
                    state.startPoint = [e.lngLat.lng, e.lngLat.lat];
                } else {
                    const endPoint = [e.lngLat.lng, e.lngLat.lat];
                    if (endPoint[0] !== state.startPoint[0] || endPoint[1] !== state.startPoint[1]) {
                        this.updateUIClasses({ mouse: 'pointer' });
                        state.rectangle.updateCoordinate('0.4', ...state.startPoint);
                        this.changeMode('simple_select', { featuresId: [state.rectangle.id] });
                    }
                }
            },
            onMouseMove(state, e) {
                if (state.startPoint) {
                    const start = state.startPoint;
                    const current = [e.lngLat.lng, e.lngLat.lat];
                    state.rectangle.updateCoordinate('0.0', start[0], start[1]);
                    state.rectangle.updateCoordinate('0.1', current[0], start[1]);
                    state.rectangle.updateCoordinate('0.2', current[0], current[1]);
                    state.rectangle.updateCoordinate('0.3', start[0], current[1]);
                    state.rectangle.updateCoordinate('0.4', start[0], start[1]);
                }
            },
            onStop(state) {
                this.map.doubleClickZoom.enable();
                this.updateUIClasses({ mouse: 'none' });
                this.activateUIButton();
                if (!state.rectangle.getCoordinate('0.0')) return;
                if (state.rectangle.isValid()) {
                    state.rectangle.removeCoordinate('0.4');
                    this.map.fire('draw.create', { features: [state.rectangle.toGeoJSON()] });
                } else {
                    this.deleteFeature([state.rectangle.id], { silent: true });
                }
            },
            toDisplayFeatures(state, geojson, display) {
                const isActive = geojson.properties.id === state.rectangle.id;
                geojson.properties.active = isActive ? 'true' : 'false';
                if (!isActive) return display(geojson);
                if (!state.startPoint) return;
                return display(geojson);
            },
            onTrash(state) {
                this.deleteFeature([state.rectangle.id], { silent: true });
                this.changeMode('simple_select');
            }
        };

        // Custom lasso drawing mode with fixed keyboard handling
        const DrawLasso = {
            onSetup(opts) {
                const lasso = this.newFeature({
                    type: 'Feature',
                    properties: {},
                    geometry: {
                        type: 'Polygon',
                        coordinates: [[]]
                    }
                });
                this.addFeature(lasso);
                this.clearSelectedFeatures();
                this.map.doubleClickZoom.disable();
                this.updateUIClasses({ mouse: 'crosshair' });
                this.setActionableState({ trash: true });

                const state = { 
                    lasso, 
                    points: [], 
                    startPoint: null,
                    mode: 'draw_lasso'
                };

                const keydownHandler = (e) => {
                    if (e.key === 'Escape' || e.key === 'Enter') {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        if (state.points && state.points.length >= 3) {
                            // Close the lasso by connecting back to first point
                            const coordinates = [...state.points];
                            if (coordinates[0] !== coordinates[coordinates.length - 1]) {
                                coordinates.push(coordinates[0]);
                            }
                            
                            // Update the feature with closed coordinates
                            for (let i = 0; i < coordinates.length; i++) {
                                state.lasso.updateCoordinate(`0.${i}`, ...coordinates[i]);
                            }
                            
                            if (state.lasso.isValid()) {
                                this.map.fire('draw.create', { features: [state.lasso.toGeoJSON()] });
                            }
                        } else {
                            // Not enough points, just delete the feature
                            this.deleteFeature([state.lasso.id], { silent: true });
                        }
                        
                        // Clean up and exit drawing mode
                        document.removeEventListener('keydown', keydownHandler);
                        this.changeMode('simple_select');
                    }
                };

                document.addEventListener('keydown', keydownHandler);
                state.keydownHandler = keydownHandler;

                return state;
            },
            onClick(state, e) {
                const point = [e.lngLat.lng, e.lngLat.lat];
                
                if (!state.startPoint) {
                    state.startPoint = point;
                    state.points.push(point);
                } else {
                    const startPixel = this.map.project(state.startPoint);
                    const currentPixel = this.map.project(point);
                    const distance = Math.sqrt(
                        Math.pow(startPixel.x - currentPixel.x, 2) + 
                        Math.pow(startPixel.y - currentPixel.y, 2)
                    );
                    
                    if (distance < 10 && state.points.length >= 3) {
                        state.points.push(state.startPoint);
                        this.updateLasso(state);
                        
                        if (state.lasso.isValid()) {
                            this.map.fire('draw.create', { features: [state.lasso.toGeoJSON()] });
                        }
                        this.changeMode('simple_select');
                    } else {
                        state.points.push(point);
                        this.updateLasso(state);
                    }
                }
            },
            onMouseMove(state, e) {
                if (state.points.length > 0) {
                    const currentPoints = [...state.points, [e.lngLat.lng, e.lngLat.lat]];
                    this.updateLasso(state, currentPoints);
                }
            },
            updateLasso(state, points = state.points) {
                if (points.length < 3) return;
                
                const coordinates = [...points];
                if (coordinates[0] !== coordinates[coordinates.length - 1]) {
                    coordinates.push(coordinates[0]);
                }
                
                for (let i = 0; i < coordinates.length; i++) {
                    state.lasso.updateCoordinate(`0.${i}`, ...coordinates[i]);
                }
            },
            onStop(state) {
                this.map.doubleClickZoom.enable();
                this.updateUIClasses({ mouse: 'none' });
                this.activateUIButton();
                
                if (state.keydownHandler) {
                    document.removeEventListener('keydown', state.keydownHandler);
                }
                
                if (state.points.length < 3) {
                    this.deleteFeature([state.lasso.id], { silent: true });
                    return;
                }
                
                const coordinates = [...state.points];
                coordinates.push(coordinates[0]);
                
                for (let i = 0; i < coordinates.length; i++) {
                    state.lasso.updateCoordinate(`0.${i}`, ...coordinates[i]);
                }
                
                if (state.lasso.isValid()) {
                    this.map.fire('draw.create', { features: [state.lasso.toGeoJSON()] });
                } else {
                    this.deleteFeature([state.lasso.id], { silent: true });
                }
            },
            toDisplayFeatures(state, geojson, display) {
                const isActive = geojson.properties.id === state.lasso.id;
                geojson.properties.active = isActive ? 'true' : 'false';
                if (!isActive) return display(geojson);
                if (state.points.length < 2) return;
                return display(geojson);
            },
            onTrash(state) {
                if (state.keydownHandler) {
                    document.removeEventListener('keydown', state.keydownHandler);
                }
                this.deleteFeature([state.lasso.id], { silent: true });
                this.changeMode('simple_select');
            }
        };

        // Helper functions
        async function loadLayer(name) {
            try {
                const response = await fetch(`/api/${name}`);
                const geojson = await response.json();
                if (map.getSource(name)) {
                    map.getSource(name).setData(geojson);
                }
            } catch (error) {
                console.error(`Error loading ${name} layer:`, error);
            }
        }

        function updateSliderFill(slider) {
            const value = slider.value;
            const max = slider.max;
            const percentage = (value / max) * 100;
            slider.style.background = `linear-gradient(to right, #4a90e2 0%, #4a90e2 ${percentage}%, rgba(255, 255, 255, 0.2) ${percentage}%, rgba(255, 255, 255, 0.2) 100%)`;
        }

        function normalizeWeights() {
            const total = Array.from(weightSliders).reduce((sum, slider) => {
                const isExcluded = document.getElementById(`exclude-${slider.id}`).checked;
                return sum + (isExcluded ? 0 : parseFloat(slider.value));
            }, 0);
            
            weightSliders.forEach(slider => {
                const isExcluded = document.getElementById(`exclude-${slider.id}`).checked;
                const normalized = total > 0 && !isExcluded ? (parseFloat(slider.value) / total * 100).toFixed(0) : 0;
                document.getElementById(slider.id + '-value').textContent = normalized + '%';
            });
        }

        function updateMaxParcels() {
            const budget = parseFloat(document.getElementById('budget').value) || 0;
            const costPerParcel = parseFloat(document.getElementById('cost-per-parcel').value) || 1;
            const maxParcels = Math.floor(budget / costPerParcel);
            document.getElementById('max-parcels').value = maxParcels;
            document.getElementById('max-parcels-value').textContent = maxParcels;
        }

        function getSelectedAspectDirections() {
            return Array.from(aspectExcludeCheckboxes)
                .filter(cb => cb.checked)
                .map(cb => cb.value);
        }

        function getCurrentFilters() {
            return {
                yearbuilt_max: document.getElementById('filter-yearbuilt-enabled').checked ? 
                    parseInt(document.getElementById('filter-yearbuilt').value) : null,
                exclude_yearbuilt_unknown: document.getElementById('filter-yearbuilt-exclude-unknown').checked,
                neigh1d_max: document.getElementById('filter-neigh1d-enabled').checked ? 
                    parseInt(document.getElementById('filter-neigh1d').value) : null,
                strcnt_min: document.getElementById('filter-strcnt-enabled').checked ? 
                    parseInt(document.getElementById('filter-strcnt').value) : null,
                exclude_wui_min30: document.getElementById('filter-wui-min30-enabled').checked,
                exclude_vhsz_min10: document.getElementById('filter-vhsz-min10-enabled').checked,
                exclude_no_brns: document.getElementById('filter-brns-enabled').checked,

                use_quantiled_scores: document.getElementById('use-quantiled-scores').checked,
                use_quantile: document.getElementById('use-quantile').checked,
                use_local_normalization: document.getElementById('use-local-normalization').checked,
                subset_area: subsetArea
            };
        }

        function getActiveScoreVariable(baseVar) {
            const useQuantile = document.getElementById('use-quantile').checked;
            const useQuantiled = document.getElementById('use-quantiled-scores').checked;
            if (useQuantile) {
                return baseVar + '_z';
            } else if (useQuantiled) {
                return baseVar + '_q';
            } else {
                return baseVar + '_s';
            }
        }

        function createPopupContent(props) {
            const useQuantile = document.getElementById('use-quantile').checked;
            const useQuantiled = document.getElementById('use-quantiled-scores').checked;
            const suffix = useQuantile ? '_z' : (useQuantiled ? '_q' : '_s');
            const scoreType = useQuantile ? 'Quantile' : (useQuantiled ? 'Robust Min-Max' : 'Basic Min-Max');
            
            return `
                <div style="max-height: 300px; overflow-y: auto; padding-right: 10px;">
                    <h3>${props.apn || 'Parcel Information'}</h3>
                    
                    <div style="margin: 10px 0; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 4px;">
                        <p style="margin: 0;"><strong>Total Score:</strong> ${props.score?.toFixed(3) || 'N/A'}</p>
                        <p style="margin: 5px 0 0 0;"><strong>Rank:</strong> ${props.rank || 'N/A'}</p>
                    </div>

                    <div style="margin: 10px 0;">
                        <h4 style="margin: 0 0 5px 0; font-size: 12px; color: #aaa;">Risk Factor Scores (${scoreType})</h4>
                        <p><strong>Structures (1/4 mi):</strong> ${props['qtrmi' + suffix]?.toFixed(3) || 'N/A'}</p>
                        <p><strong>WUI Coverage (1/2 mi):</strong> ${props['hwui' + suffix]?.toFixed(3) || 'N/A'}</p>
                        <p><strong>Agriculture Coverage (1/2 mi):</strong> ${props['hagri' + suffix]?.toFixed(3) || 'N/A'}</p>
                        <p><strong>Fire Hazard Coverage (1/2 mi):</strong> ${props['hvhsz' + suffix]?.toFixed(3) || 'N/A'}</p>
                        <p><strong>Firebreak Coverage (1/2 mi):</strong> ${props['hfb' + suffix]?.toFixed(3) || 'N/A'}</p>
                        <p><strong>Slope Score:</strong> ${props['slope' + suffix]?.toFixed(3) || 'N/A'}</p>
                        <p><strong>Neighbor Distance Score:</strong> ${props['neigh1d' + suffix]?.toFixed(3) || 'N/A'}</p>
                        <p><strong>Burn Scar Coverage (1/2 mi):</strong> ${props['hbrn' + suffix]?.toFixed(3) || 'N/A'}</p>
                    </div>

                    <div style="margin: 10px 0;">
                        <h4 style="margin: 0 0 5px 0; font-size: 12px; color: #aaa;">Raw Values</h4>
                        <p><strong>Nearest Neighbor Distance:</strong> ${props.neigh1_d?.toFixed(2) || 'N/A'} ft</p>
                        <p><strong>Structures in 1/4 mi:</strong> ${props.qtrmi_cnt || 'N/A'}</p>
                        <p><strong>Number of Burn Scars:</strong> ${props.num_brns || 'N/A'}</p>
                        <p><strong>Parcel Slope:</strong> ${props.avg_slope?.toFixed(2) || 'N/A'}°</p>
                        <p><strong>WUI % (1/2 mi):</strong> ${props.hlfmi_wui?.toFixed(2) || 'N/A'}%</p>
                        <p><strong>Fire VHSZ % (1/2 mi):</strong> ${props.hlfmi_vhsz?.toFixed(2) || 'N/A'}%</p>
                        <p><strong>Year Built:</strong> ${props.yearbuilt || 'Unknown'}</p>
                        <p><strong>Max Slope:</strong> ${props.max_slope?.toFixed(2) || 'N/A'}°</p>
                        <p><strong>Agricultural % (1/2 mi):</strong> ${props.hlfmi_agri?.toFixed(2) || 'N/A'}%</p>
                        <p><strong>Firebreak % (1/2 mi):</strong> ${props.hlfmi_fb?.toFixed(2) || 'N/A'}%</p>
                        <p><strong>Burn Scar % (1/2 mi, Raw):</strong> ${props.hlfmi_brn?.toFixed(2) || 'N/A'}%</p>
                        <p><strong>Number of Neighbors:</strong> ${props.num_neighb || 'N/A'}</p>
                        <p><strong>Structure Count:</strong> ${props.strcnt || 'N/A'}</p>
                        <p><strong>Burn Scar % (1/2 mi):</strong> ${props.hbrn_s?.toFixed(2) || 'N/A'}%</p>
                        <p><strong>Perimeter:</strong> ${props.perimeter?.toFixed(2) || 'N/A'} ft</p>
                        <p><strong>Elevation:</strong> ${props.par_elev?.toFixed(2) || 'N/A'} ft</p>
                        <p><strong>Aspect:</strong> ${props.par_aspe_1 || 'N/A'}</p>
                    </div>
                </div>
            `;
        }

        function createBurnscarPopupContent(props) {
            return `
                <div style="color: #ffffff; font-family: Arial, sans-serif; max-width: 300px;">
                    <h3 style="margin: 0 0 10px 0; color: #cc7722; border-bottom: 2px solid #cc7722; padding-bottom: 5px;">
                        ${props.incidentna || 'Unknown Fire'} Fire
                    </h3>
                    <div style="margin: 10px 0;">
                        <p><strong>Fire Year:</strong> ${props.fireyear ? Math.round(props.fireyear) : 'Unknown'}</p>
                        <p><strong>Acres Burned:</strong> ${props.gisacres ? props.gisacres.toLocaleString() + ' acres' : 'Unknown'}</p>
                        <p><strong>Fire ID:</strong> ${props.id || 'N/A'}</p>
                    </div>
                </div>
            `;
        }

        // Initialize map
        mapboxgl.accessToken = '{{ mapbox_token }}' || 'YOUR_MAPBOX_TOKEN';
        
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/dark-v11',
            center: [-119.758714, 34.44195],
            zoom: 11,
            pitch: 0,
            bearing: 0
        });

        // Initialize drawing
        const draw = new MapboxDraw({
            displayControlsDefault: false,
            modes: {
                ...MapboxDraw.modes,
                draw_rectangle: DrawRectangle,
                draw_lasso: DrawLasso
            },
            controls: {
                polygon: false,
                trash: false
            },
            styles: [
                {
                    'id': 'gl-draw-polygon-fill-inactive',
                    'type': 'fill',
                    'filter': ['all', ['==', 'active', 'false'], ['==', '$type', 'Polygon']],
                    'paint': {
                        'fill-color': '#ffcc00',
                        'fill-outline-color': '#ffcc00',
                        'fill-opacity': 0.3
                    }
                },
                {
                    'id': 'gl-draw-polygon-stroke-inactive',
                    'type': 'line',
                    'filter': ['all', ['==', 'active', 'false'], ['==', '$type', 'Polygon']],
                    'paint': {
                        'line-color': '#ffcc00',
                        'line-width': 2
                    }
                },
                {
                    'id': 'gl-draw-polygon-fill-active',
                    'type': 'fill',
                    'filter': ['all', ['==', 'active', 'true'], ['==', '$type', 'Polygon']],
                    'paint': {
                        'fill-color': '#ffcc00',
                        'fill-outline-color': '#ffcc00',
                        'fill-opacity': 0.3
                    }
                },
                {
                    'id': 'gl-draw-polygon-stroke-active',
                    'type': 'line',
                    'filter': ['all', ['==', 'active', 'true'], ['==', '$type', 'Polygon']],
                    'paint': {
                        'line-color': '#ffcc00',
                        'line-width': 2
                    }
                }
            ]
        });
        map.addControl(draw, 'top-right');

        // State variables
        let currentData = null;
        let currentSessionId = null;
        let selectedParcels = [];
        let measureMode = false;
        let measurePoints = [];
        let measureLine = null;
        let subsetArea = null;
        
        // Multi-area selection for weight inference
        let selectionAreas = [];
        let isAddingSelection = false;
        
        // Variables to store solution files content
        let currentLpContent = null;
        let currentTxtContent = null;

        // Get DOM elements
        const weightSliders = document.querySelectorAll('.weight-slider');
        const aspectExcludeCheckboxes = document.querySelectorAll('.aspect-exclude');
        const modal = document.getElementById('dist-modal');
        const closeModal = document.getElementsByClassName('close-modal')[0];
        const measureButton = document.createElement('button');
        measureButton.className = 'button';
        measureButton.textContent = 'Measure Distance';
        measureButton.style.marginBottom = '10px';
        document.getElementById('measure-container').insertBefore(measureButton, document.getElementById('distance'));

        // Raw variable mapping for distribution plots
        const rawVarMap = {
            'qtrmi': 'qtrmi_cnt',
            'hwui': 'hlfmi_wui',
            'hagri': 'hlfmi_agri',
            'hvhsz': 'hlfmi_vhsz',
            'hfb': 'hlfmi_fb',
            'slope': 'slope_s',
            'neigh1d': 'neigh1_d',
            'hbrn': 'hlfmi_brn'
        };

        // Variable name mapping for readable titles
        const varNameMap = {
            'qtrmi_cnt': 'Quarter Mile Count',
            'hlfmi_wui': 'WUI Score',
            'hlfmi_agri': 'Agriculture Score',
            'hlfmi_vhsz': 'Very High Fire Hazard',
            'hlfmi_fb': 'Fuel Break Score',
            'slope_s': 'Slope Score',
            'neigh1_d': 'Neighbor Distance',
            'hlfmi_brn': 'Burn Score',
            'qtrmi_s': 'Quarter Mile Score',
            'qtrmi_q': 'Quarter Mile Score (Robust Min-Max)',
            'qtrmi_z': 'Quarter Mile Score (Quantile)',
            'hwui_s': 'WUI Score',
            'hwui_q': 'WUI Score (Robust Min-Max)',
            'hwui_z': 'WUI Score (Quantile)',
            'hagri_s': 'Agriculture Score',
            'hagri_q': 'Agriculture Score (Robust Min-Max)',
            'hagri_z': 'Agriculture Score (Quantile)',
            'hvhsz_s': 'Very High Fire Hazard Score',
            'hvhsz_q': 'Very High Fire Hazard Score (Robust Min-Max)',
            'hvhsz_z': 'Very High Fire Hazard Score (Quantile)',
            'hfb_s': 'Fuel Break Score',
            'hfb_q': 'Fuel Break Score (Robust Min-Max)',
            'hfb_z': 'Fuel Break Score (Quantile)',
            'slope_s': 'Slope Score',
            'slope_q': 'Slope Score (Robust Min-Max)',
            'slope_z': 'Slope Score (Quantile)',
            'neigh1d_s': 'Neighbor Distance Score',
            'neigh1d_q': 'Neighbor Distance Score (Robust Min-Max)',
            'neigh1d_z': 'Neighbor Distance Score (Quantile)',
            'hbrn_s': 'Burn Score',
            'hbrn_q': 'Burn Score (Robust Min-Max)',
            'hbrn_z': 'Burn Score (Quantile)'
        };

        // Enhanced update scores function with comprehensive client-side processing
        async function updateScores(isFilterChange = false) {
            const overallStartTime = performance.now();
            console.log(`=== ${isFilterChange ? 'FULL LOAD' : 'CLIENT PROCESSING'} STARTED ===`);
            
            document.getElementById('spinner').style.display = 'block';
            
            // Get current weights
            const weights = {};
            const total = Array.from(weightSliders).reduce((sum, slider) => {
                const isExcluded = document.getElementById(`exclude-${slider.id}`).checked;
                return sum + (isExcluded ? 0 : parseFloat(slider.value));
            }, 0);
            
            weightSliders.forEach(slider => {
                const isExcluded = document.getElementById(`exclude-${slider.id}`).checked;
                weights[slider.id] = total > 0 && !isExcluded ? parseFloat(slider.value) / total : 0;
            });
            
            const maxParcels = parseInt(document.getElementById('max-parcels').value);
            const filters = getCurrentFilters();
            
            try {
                // Check if we have complete dataset stored and can use client-side processing
                if (window.fireRiskScoring.getCompleteDatasetCount() > 0) {
                    console.log('Using comprehensive client-side processing (filtering + scoring)');
                    
                    // Use the new processData method for everything client-side
                    const clientResult = window.fireRiskScoring.processData(
                        weights, 
                        filters, 
                        maxParcels,
                        filters.use_local_normalization,
                        filters.use_quantile,
                        filters.use_quantiled_scores
                    );
                    
                    if (clientResult) {
                        // Update current data
                        currentData = clientResult;
                        updateMap();
                        updateStatistics();
                        
                        // Update normalization display with client-side stats
                        updateNormalizationDisplay(filters);
                        
                        // Auto-refresh score distribution plot if the modal is open
                        if (modal.style.display === 'block') {
                            refreshScoreDistributionPlot();
                        }
                        
                        const totalTime = performance.now() - overallStartTime;
                        console.log(`=== CLIENT PROCESSING COMPLETED in ${totalTime.toFixed(1)}ms ===`);
                        return;
                    }
                }
                
                // First time load: fetch complete dataset from server
                console.log('Loading complete dataset from server (first time)');
                
                const responseData = await window.apiClient.prepareData({
                    weights,
                    use_quantiled_scores: filters.use_quantiled_scores,
                    use_quantile: filters.use_quantile,
                    use_local_normalization: filters.use_local_normalization,
                    max_parcels: maxParcels,
                    subset_area: filters.subset_area,
                    ...filters
                });
                
                // Store complete dataset for future client-side processing
                window.fireRiskScoring.storeCompleteData(responseData);
                
                // Update current data and map
                currentData = responseData;
                updateMap();
                updateStatistics();
                
                // Update normalization mode display
                if (responseData.use_local_normalization !== undefined) {
                    document.getElementById('normalization-row').style.display = 'flex';
                    if (responseData.use_local_normalization) {
                        document.getElementById('normalization-mode').textContent = 
                            `Local (${responseData.total_parcels_after_filter} parcels)`;
                        document.getElementById('local-norm-info').style.display = 'block';
                        document.getElementById('local-norm-status').textContent = 
                            `✓ Scores renormalized on ${responseData.total_parcels_after_filter} filtered parcels`;
                    } else {
                        document.getElementById('normalization-mode').textContent = 
                            `Global (${responseData.total_parcels_after_filter} of ${responseData.total_parcels_before_filter} parcels)`;
                        document.getElementById('local-norm-info').style.display = 'none';
                    }
                }
                
                // Auto-refresh score distribution plot if the modal is open
                if (modal.style.display === 'block') {
                    refreshScoreDistributionPlot();
                }
                
                const totalTime = performance.now() - overallStartTime;
                console.log(`=== INITIAL LOAD COMPLETED in ${totalTime.toFixed(1)}ms ===`);
                
            } catch (error) {
                console.error('Error updating scores:', error);
                alert('Error loading data. Please try again.');
            } finally {
                document.getElementById('spinner').style.display = 'none';
            }
        }

        // Helper function to update normalization display with client-side data
        function updateNormalizationDisplay(filters) {
            const filterStats = window.clientFilterManager.getFilterStats();
            if (filterStats) {
                document.getElementById('normalization-row').style.display = 'flex';
                if (filters.use_local_normalization) {
                    document.getElementById('normalization-mode').textContent = 
                        `Local (${filterStats.total_parcels_after_filter} parcels)`;
                    document.getElementById('local-norm-info').style.display = 'block';
                    document.getElementById('local-norm-status').textContent = 
                        `✓ Scores renormalized on ${filterStats.total_parcels_after_filter} filtered parcels`;
                } else {
                    document.getElementById('normalization-mode').textContent = 
                        `Global (${filterStats.total_parcels_after_filter} of ${filterStats.total_parcels_before_filter} parcels)`;
                    document.getElementById('local-norm-info').style.display = 'none';
                }
            }
        }

        // Multi-area selection management
        function updateSelectionCount() {
            document.getElementById('selection-count').textContent = selectionAreas.length;
            
            // Update button states
            const hasSelections = selectionAreas.length > 0;
            document.getElementById('clear-last-selection').disabled = !hasSelections;
            document.getElementById('clear-all-selections').disabled = !hasSelections;
            document.getElementById('infer-weights').disabled = !hasSelections;
            
            // Clear solution files when selections change
            if (hasSelections) {
                currentLpContent = null;
                currentTxtContent = null;
                document.getElementById('download-lp-btn').disabled = true;
                document.getElementById('view-solution-btn').disabled = true;
            }
        }

        function addSelectionArea(geometry, type, featureId = null) {
            const selectionId = featureId || `selection_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            selectionAreas.push({
                id: selectionId,
                featureId: featureId,
                geometry: geometry,
                type: type,
                timestamp: Date.now()
            });
            
            updateSelectionCount();
            console.log(`Added ${type} selection area. Total areas: ${selectionAreas.length}`);
        }

        function removeLastSelectionArea() {
            if (selectionAreas.length > 0) {
                const removed = selectionAreas.pop();
                
                // Remove the corresponding drawn feature if it has a featureId
                if (removed.featureId) {
                    const allFeatures = draw.getAll();
                    const featureToDelete = allFeatures.features.find(f => f.id === removed.featureId);
                    if (featureToDelete) {
                        draw.delete(removed.featureId);
                    }
                }
                
                updateSelectionCount();
                console.log(`Removed last selection area (${removed.type}). Remaining: ${selectionAreas.length}`);
            }
        }

        function clearAllSelectionAreas() {
            // Clear all drawn features that are part of our selection areas
            selectionAreas.forEach(area => {
                if (area.featureId) {
                    try {
                        draw.delete(area.featureId);
                    } catch (e) {
                        // Feature might already be deleted, ignore
                    }
                }
            });
            
            // Also clear any remaining drawn features
            draw.deleteAll();
            
            selectionAreas = [];
            updateSelectionCount();
            console.log('Cleared all selection areas');
        }

        function combineSelectionAreas() {
            if (selectionAreas.length === 0) return null;
            
            if (selectionAreas.length === 1) {
                return selectionAreas[0].geometry;
            }
            
            // For multiple areas, create a union using Turf.js
            if (window.turf && window.turf.union && window.turf.feature) {
                try {
                    console.log(`Combining ${selectionAreas.length} selection areas using Turf.js`);
                    
                    let combined = window.turf.feature(selectionAreas[0].geometry);
                    
                    for (let i = 1; i < selectionAreas.length; i++) {
                        const nextFeature = window.turf.feature(selectionAreas[i].geometry);
                        combined = window.turf.union(combined, nextFeature);
                    }
                    
                    console.log(`Union result type: ${combined.geometry.type}`);
                    
                    // Return just the geometry, not the full feature
                    return combined.geometry;
                } catch (error) {
                    console.error('Failed to union selection areas:', error);
                    // Fall back to returning all areas as separate features for backend OR processing
                    console.log('Falling back to FeatureCollection approach');
                    return {
                        type: "FeatureCollection",
                        features: selectionAreas.map(area => ({
                            type: "Feature",
                            geometry: area.geometry
                        }))
                    };
                }
            } else {
                console.warn('Turf.js not fully available, using FeatureCollection fallback');
                // Return all areas as separate features for backend OR processing
                return {
                    type: "FeatureCollection",
                    features: selectionAreas.map(area => ({
                        type: "Feature",
                        geometry: area.geometry
                    }))
                };
            }
        }

        function updateStatistics() {
            if (!currentData || !currentData.features) return;
            
            const totalParcels = currentData.features.length;
            const selectedCount = currentData.features.filter(f => f.properties.top500).length;
            const totalRisk = currentData.features
                .filter(f => f.properties.top500)
                .reduce((sum, f) => sum + f.properties.score, 0);
            const avgRisk = selectedCount > 0 ? totalRisk / selectedCount : 0;
            
            document.getElementById('total-parcels').textContent = totalParcels.toLocaleString();
            document.getElementById('selected-parcels').textContent = selectedCount.toLocaleString();
            document.getElementById('total-risk').textContent = totalRisk.toFixed(2);
            document.getElementById('avg-risk').textContent = avgRisk.toFixed(2);
        }
        
        function updateMap() {
            if (!currentData) return;
            
            if (map.getSource('parcels')) {
                map.getSource('parcels').setData(currentData);
            }
        }
        


        function exitMeasureMode() {
            measureMode = false;
            measureButton.textContent = 'Measure Distance';
            if (measureLine) {
                map.removeLayer('measure-line');
                map.removeSource('measure-line');
            }
            measurePoints = [];
            document.getElementById('distance').textContent = '';
        }
 
        async function showDistribution(variable) {
            // Always fetch distribution with current filters
            const filters = getCurrentFilters();
            
            // If this is a score variable (ends with _s, _q, or _z), use the correct suffix based on settings
            if (variable.endsWith('_s') || variable.endsWith('_q') || variable.endsWith('_z')) {
                const baseVar = variable.slice(0, -2); // Remove _s, _q, or _z
                if (filters.use_quantile) {
                    variable = baseVar + '_z';
                } else if (filters.use_quantiled_scores) {
                    variable = baseVar + '_q';
                } else {
                    variable = baseVar + '_s';
                }
            } else {
                // For raw variables, use the mapped name
                variable = rawVarMap[variable] || variable;
            }
            
            try {
                const response = await fetch(`/api/distribution/${variable}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify(filters)
                });
                const data = await response.json();
                if (!response.ok) {
                    throw new Error(data.error || response.statusText);
                }
                
                // Calculate mean
                const mean = data.values.reduce((a, b) => a + b, 0) / data.values.length;
                
                const trace = {
                    x: data.values,
                    type: 'histogram',
                    marker: {
                        color: '#4a90e2',
                        line: {
                            color: 'rgba(200,200,200,0.3)',
                            width: 1
                        }
                    },
                    nbinsx: 30
                };
                
                // Create annotation for statistics
                const statsText = `Min: ${data.min.toFixed(2)}<br>Max: ${data.max.toFixed(2)}<br>Mean: ${mean.toFixed(2)}<br>Count: ${data.count}`;
                
                const layout = {
                    title: `${varNameMap[variable] || variable} Distribution`,
                    paper_bgcolor: '#1a1a1a',
                    plot_bgcolor: '#1a1a1a',
                    font: {
                        color: '#fff'
                    },
                    xaxis: {
                        title: `${varNameMap[variable] || variable}`,
                        gridcolor: 'rgba(255,255,255,0.1)'
                    },
                    yaxis: {
                        title: 'Count',
                        gridcolor: 'rgba(255,255,255,0.1)'
                    },
                    showlegend: false,
                    bargap: 0,
                    displayModeBar: false,
                    annotations: [{
                        x: 0.98,
                        y: 0.98,
                        xref: 'paper',
                        yref: 'paper',
                        text: statsText,
                        showarrow: false,
                        font: {
                            color: '#fff',
                            size: 12
                        },
                        bgcolor: 'rgba(0,0,0,0.5)',
                        bordercolor: 'rgba(255,255,255,0.3)',
                        borderwidth: 1,
                        borderpad: 4,
                        xanchor: 'right',
                        yanchor: 'top'
                    }]
                };
                Plotly.newPlot('dist-plot', [trace], layout);
                modal.style.display = "block";
            } catch (error) {
                console.error('Error fetching distribution:', error);
                alert('Error loading distribution data');
            }
        }

        // Event listeners
        document.getElementById('parcels-opacity').addEventListener('input', (e) => {
            const opacity = parseInt(e.target.value) / 100;
            if (map.getLayer('parcels-fill')) {
                map.setPaintProperty('parcels-fill', 'fill-opacity', opacity);
            }
        });

        weightSliders.forEach(slider => {
            updateSliderFill(slider);
            slider.addEventListener('input', () => {
                updateSliderFill(slider);
                normalizeWeights();
                // Don't auto-calculate on weight changes - wait for Calculate button
            });
        });

        // Calculate button - all processing is now client-side after initial load
        document.getElementById('calculate-btn').addEventListener('click', () => {
            updateScores(); // Always use client-side processing
        });
        document.getElementById('budget').addEventListener('change', () => {
            updateMaxParcels();
            // Clear complete dataset to force reload with new parcel count
            window.fireRiskScoring.clear();
            updateScores();
        });
        document.getElementById('cost-per-parcel').addEventListener('change', () => {
            updateMaxParcels();
            // Clear complete dataset to force reload with new parcel count
            window.fireRiskScoring.clear();
            updateScores();
        });
        document.getElementById('max-parcels').addEventListener('change', () => {
            // Max parcels change only affects ranking, no need to clear complete dataset
            updateScores();
        });

        // Filter and normalization controls - all use client-side processing
        const filters = ['filter-yearbuilt-enabled', 'filter-neigh1d-enabled', 'filter-yearbuilt-exclude-unknown', 
                        'filter-strcnt-enabled', 'filter-wui-min30-enabled', 'filter-vhsz-min10-enabled', 
                        'filter-brns-enabled', 'use-basic-scores', 'use-quantiled-scores', 'use-quantile',
                        'use-local-normalization'];
        filters.forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                updateScores(); // Client-side processing handles all changes
            });
        });

        ['filter-yearbuilt', 'filter-neigh1d', 'filter-strcnt'].forEach(id => {
            const element = document.getElementById(id);
            element.addEventListener('change', () => {
                updateScores();
            });
            element.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    updateScores();
                }
            });
        });

        aspectExcludeCheckboxes.forEach(cb => {
            cb.addEventListener('change', () => {
                updateScores();
            });
        });

        // Download .LP file (client-side)
        document.getElementById('download-lp-btn').addEventListener('click', () => {
            if (!currentLpContent) {
                alert('No LP file available. Run weight inference first.');
                return;
            }
            
            try {
                // Create and download file entirely on client-side (no backend needed)
                const blob = new Blob([currentLpContent], { type: 'text/plain' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'fire_risk_optimization.lp';
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Error downloading LP file:', error);
                alert('Failed to download LP file. Please try again.');
            }
        });

        // View solution report in modal
        document.getElementById('view-solution-btn').addEventListener('click', () => {
            if (!currentTxtContent) {
                alert('No solution report available. Run weight inference first.');
                return;
            }
            
            document.getElementById('solution-text').textContent = currentTxtContent;
            document.getElementById('solution-modal').style.display = 'block';
        });

        // Multi-area selection handlers - Add Rectangle
        document.getElementById('draw-rectangle').addEventListener('click', () => {
            isAddingSelection = true;
            draw.changeMode('draw_rectangle');
        });

        // Multi-area selection handlers - Add Lasso
        document.getElementById('draw-lasso').addEventListener('click', () => {
            isAddingSelection = true;
            draw.changeMode('draw_lasso');
        });

        // Multi-area selection handlers - Remove Last
        document.getElementById('clear-last-selection').addEventListener('click', () => {
            removeLastSelectionArea();
        });

        // Multi-area selection handlers - Clear All
        document.getElementById('clear-all-selections').addEventListener('click', () => {
            clearAllSelectionAreas();
        });
        
        // Subset selection event handlers
        document.getElementById('subset-rectangle').addEventListener('click', () => {
            draw.deleteAll();
            draw.changeMode('draw_rectangle');
            document.getElementById('subset-rectangle').dataset.mode = 'subset';
        });

        document.getElementById('subset-lasso').addEventListener('click', () => {
            draw.deleteAll();
            draw.changeMode('draw_lasso');
            document.getElementById('subset-lasso').dataset.mode = 'subset';
        });

        document.getElementById('clear-subset').addEventListener('click', () => {
            subsetArea = null;
            document.getElementById('subset-indicator').style.display = 'none';
            document.getElementById('filter-parcels').disabled = true;
            
            // Clear any drawn shapes
            draw.deleteAll();
            
            // Use client-side processing to remove spatial filter
            updateScores();
        });

        document.getElementById('filter-parcels').addEventListener('click', () => {
            const features = draw.getAll().features;
            if (features.length && subsetArea) {
                console.log('Applying spatial filter with subsetArea:', subsetArea);
                document.getElementById('subset-indicator').style.display = 'block';
                
                // Clear the drawn shape from the map after filtering
                draw.deleteAll();
                
                // Use client-side processing for spatial filtering
                updateScores();
            } else {
                console.log('No features or subsetArea to filter with. Features:', features.length, 'subsetArea:', subsetArea);
            }
        });
        
        // Multi-area infer weights handler
        document.getElementById('infer-weights').addEventListener('click', async () => {
            if (selectionAreas.length === 0) {
                alert('Please draw at least one selection area first!');
                return;
            }

            const combinedSelection = combineSelectionAreas();
            if (!combinedSelection) {
                alert('Error combining selection areas. Please try again.');
                return;
            }

            const maxParcels = parseInt(document.getElementById('max-parcels').value);

            const includeVars = Array.from(weightSliders)
                .map(slider => slider.id)
                .filter(varName => {
                    const cb = document.getElementById(`exclude-${varName}`);
                    return cb && !cb.checked;
                });

            document.getElementById('spinner').style.display = 'block';

            try {
                console.log(`Optimizing weights for ${selectionAreas.length} selection areas:`, 
                    selectionAreas.map(area => area.type));

                const data = await window.apiClient.inferWeights({
                    selection: combinedSelection,
                    selection_areas: selectionAreas, // Send all individual areas for reference
                    max_parcels: maxParcels,
                    include_vars: includeVars,
                    use_quantiled_scores: document.getElementById('use-quantiled-scores').checked,
                    use_quantile: document.getElementById('use-quantile').checked,
                    ...getCurrentFilters()
                });

                // Store the solution files content for client-side download
                currentLpContent = data.lp_file_content;
                currentTxtContent = data.txt_file_content;

                // Store the optimization parcel data for correct plot display
                if (data.optimization_parcel_data) {
                    // Update selectedParcels with the actual optimization scores
                    selectedParcels = data.optimization_parcel_data.map(parcel => {
                        // Calculate weighted score using the optimal weights
                        let weightedScore = 0;
                        for (const varName in parcel.scores) {
                            const weight = data.weights[varName + '_s'] / 100; // Convert percentage to decimal
                            weightedScore += weight * parcel.scores[varName];
                        }
                        return {
                            id: parcel.id,
                            properties: {
                                score: weightedScore
                            }
                        };
                    });
                }

                // Enable the download and view buttons
                document.getElementById('download-lp-btn').disabled = false;
                document.getElementById('view-solution-btn').disabled = false;

                // Update the weight sliders with optimized values
                Object.entries(data.weights).forEach(([key, value]) => {
                    const slider = document.getElementById(key);
                    if (slider) {
                        slider.value = value;
                        updateSliderFill(slider);
                    }
                });

                normalizeWeights();
                await updateScores();
                
                // Clear the drawn features after successful optimization
                clearAllSelectionAreas();
                
            } catch (error) {
                console.error('Error inferring weights:', error);
                alert(error.message);
            } finally {
                document.getElementById('spinner').style.display = 'none';
            }
        });


        document.getElementById('export-shapefile').addEventListener('click', async () => {
            if (!currentData) return;
            
            const selectedFeatures = currentData.features.filter(f => f.properties.top500);
            const exportData = {
                type: 'FeatureCollection',
                features: selectedFeatures
            };
            
            try {
                const response = await fetch('/api/export-shapefile', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(exportData)
                });
                
                if (!response.ok) {
                    throw new Error('Export failed');
                }
                
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'fire_risk_selected_parcels.zip';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
            } catch (error) {
                console.error('Error exporting shapefile:', error);
                alert('Failed to export shapefile. Please try again.');
            }
        });

        document.getElementById('score-distribution-btn').addEventListener('click', () => {
            if (!currentData) {
                alert('Please calculate scores first');
                return;
            }

            const scores = currentData.features.map(f => f.properties.score);
            const selectedScores = currentData.features
                .filter(f => f.properties.top500)
                .map(f => f.properties.score);

            // Get selected area scores if available
            let selectedAreaScores = [];
            if (selectedParcels && selectedParcels.length > 0) {
                selectedAreaScores = selectedParcels.map(f => f.properties.score);
            }

            // Calculate statistics for all scores
            const allScoresMean = scores.reduce((a, b) => a + b, 0) / scores.length;
            const allScoresMin = Math.min(...scores);
            const allScoresMax = Math.max(...scores);
            const allScoresStd = Math.sqrt(scores.reduce((a, b) => a + Math.pow(b - allScoresMean, 2), 0) / scores.length);

            // Calculate statistics for selected scores
            const selectedScoresMean = selectedScores.reduce((a, b) => a + b, 0) / selectedScores.length;
            const selectedScoresMin = Math.min(...selectedScores);
            const selectedScoresMax = Math.max(...selectedScores);
            const selectedScoresStd = Math.sqrt(selectedScores.reduce((a, b) => a + Math.pow(b - selectedScoresMean, 2), 0) / selectedScores.length);

            // Create main histogram for all scores to get the max height
            const allScoresTrace = {
                x: scores,
                type: 'histogram',
                name: 'All Parcels',
                marker: {
                    color: '#ff6666',
                    line: {
                        color: 'rgba(200,200,200,0.3)',
                        width: 1
                    }
                },
                nbinsx: 50,
                opacity: 0.7
            };

            const traces = [allScoresTrace];

            // Calculate the expected maximum height for reference bars (1/4 of plot height)
            // We'll estimate this based on the data distribution
            const binCount = Math.ceil(scores.length / 50); // Rough estimate of max bin height
            const referenceBarHeight = binCount * 0.25; // 1/4 of expected max height

            // Add selected area bars and arrows if available
            if (selectedAreaScores.length > 0) {
                const selectedAreaMean = selectedAreaScores.reduce((a, b) => a + b, 0) / selectedAreaScores.length;
                const selectedAreaMin = Math.min(...selectedAreaScores);
                const selectedAreaMax = Math.max(...selectedAreaScores);
                
                // Add dotted bars at min and max (1/4 height)
                traces.push({
                    x: [selectedAreaMin, selectedAreaMin],
                    y: [0, referenceBarHeight],
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        color: '#ffff00',
                        width: 3,
                        dash: 'dot'
                    },
                    name: `Selected Area Min: ${selectedAreaMin.toFixed(3)}`,
                    showlegend: true
                });

                traces.push({
                    x: [selectedAreaMax, selectedAreaMax],
                    y: [0, referenceBarHeight],
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        color: '#ffff00',
                        width: 3,
                        dash: 'dot'
                    },
                    name: `Selected Area Max: ${selectedAreaMax.toFixed(3)}`,
                    showlegend: true
                });

                // Add solid bar at mean (1/4 height)
                traces.push({
                    x: [selectedAreaMean, selectedAreaMean],
                    y: [0, referenceBarHeight],
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        color: '#ffff00',
                        width: 3
                    },
                    name: `Selected Area Mean: ${selectedAreaMean.toFixed(3)}`,
                    showlegend: true
                });
            }

            const layout = {
                title: 'Calculated Risk Score Distribution',
                paper_bgcolor: '#1a1a1a',
                plot_bgcolor: '#1a1a1a',
                font: {
                    color: '#fff'
                },
                xaxis: {
                    title: 'Score',
                    gridcolor: 'rgba(255,255,255,0.1)',
                    zerolinecolor: 'rgba(255,255,255,0.1)'
                },
                yaxis: {
                    title: 'Count',
                    gridcolor: 'rgba(255,255,255,0.1)',
                    zerolinecolor: 'rgba(255,255,255,0.1)'
                },
                showlegend: true,
                legend: {
                    font: {
                        color: '#fff'
                    },
                    y: 0.95,
                    x: 0.02
                },
                bargap: 0,
                displayModeBar: false,
                margin: {
                    l: 50,
                    r: 20,
                    t: 50,
                    b: 50
                },
                height: 600,
                annotations: []
            };

            // Add statistics annotation
            let statsText = `All Parcels:<br>Min: ${allScoresMin.toFixed(3)}<br>Max: ${allScoresMax.toFixed(3)}<br>Mean: ${allScoresMean.toFixed(3)}<br>Std: ${allScoresStd.toFixed(3)}<br>Count: ${scores.length}<br><br>Top N Parcels:<br>Min: ${selectedScoresMin.toFixed(3)}<br>Max: ${selectedScoresMax.toFixed(3)}<br>Mean: ${selectedScoresMean.toFixed(3)}<br>Std: ${selectedScoresStd.toFixed(3)}<br>Count: ${selectedScores.length}`;
            
            if (selectedAreaScores.length > 0) {
                const selectedAreaMean = selectedAreaScores.reduce((a, b) => a + b, 0) / selectedAreaScores.length;
                const selectedAreaMin = Math.min(...selectedAreaScores);
                const selectedAreaMax = Math.max(...selectedAreaScores);
                const selectedAreaStd = Math.sqrt(selectedAreaScores.reduce((a, b) => a + Math.pow(b - selectedAreaMean, 2), 0) / selectedAreaScores.length);
                statsText += `<br><br>Selected Area:<br>Min: ${selectedAreaMin.toFixed(3)}<br>Max: ${selectedAreaMax.toFixed(3)}<br>Mean: ${selectedAreaMean.toFixed(3)}<br>Std: ${selectedAreaStd.toFixed(3)}<br>Count: ${selectedAreaScores.length}`;
            }

            layout.annotations.push({
                x: 0.02,
                y: 0.02,
                xref: 'paper',
                yref: 'paper',
                text: statsText,
                showarrow: false,
                font: {
                    color: '#fff',
                    size: 12
                },
                bgcolor: 'rgba(0,0,0,0.5)',
                bordercolor: 'rgba(255,255,255,0.3)',
                borderwidth: 1,
                borderpad: 4,
                xanchor: 'left',
                yanchor: 'bottom'
            });

            // Add single arrow for top parcels (blue arrow)
            const maxY = referenceBarHeight * 4; // Estimate max plot height
            const arrowY = maxY * 0.9; // Position arrows near top
            
            // Add single arrow for Top Parcels at the midpoint of selected scores
            if (selectedScores.length > 0) {
                const topParcelsScore = selectedScores[Math.floor(selectedScores.length / 2)];
                layout.annotations.push({
                    x: topParcelsScore,
                    y: arrowY,
                    text: 'Top Parcels',
                    showarrow: true,
                    arrowhead: 2,
                    arrowsize: 1,
                    arrowwidth: 2,
                    arrowcolor: '#0066ff',
                    font: {
                        color: '#0066ff',
                        size: 12
                    },
                    xanchor: 'center',
                    yanchor: 'bottom'
                });
            }

            // Add arrows for selected area scores (yellow arrows for min, mean, max)
            if (selectedAreaScores.length > 0) {
                const selectedAreaMean = selectedAreaScores.reduce((a, b) => a + b, 0) / selectedAreaScores.length;
                const selectedAreaMin = Math.min(...selectedAreaScores);
                const selectedAreaMax = Math.max(...selectedAreaScores);
                
                const yellowArrowY = arrowY * 0.7;
                
                // Min arrow
                layout.annotations.push({
                    x: selectedAreaMin,
                    y: yellowArrowY,
                    text: 'Min',
                    showarrow: true,
                    arrowhead: 2,
                    arrowsize: 1,
                    arrowwidth: 2,
                    arrowcolor: '#ffff00',
                    font: {
                        color: '#ffff00',
                        size: 12
                    },
                    xanchor: 'center',
                    yanchor: 'bottom'
                });
                
                // Mean arrow
                layout.annotations.push({
                    x: selectedAreaMean,
                    y: yellowArrowY,
                    text: 'Mean',
                    showarrow: true,
                    arrowhead: 2,
                    arrowsize: 1,
                    arrowwidth: 2,
                    arrowcolor: '#ffff00',
                    font: {
                        color: '#ffff00',
                        size: 12
                    },
                    xanchor: 'center',
                    yanchor: 'bottom'
                });
                
                // Max arrow
                layout.annotations.push({
                    x: selectedAreaMax,
                    y: yellowArrowY,
                    text: 'Max',
                    showarrow: true,
                    arrowhead: 2,
                    arrowsize: 1,
                    arrowwidth: 2,
                    arrowcolor: '#ffff00',
                    font: {
                        color: '#ffff00',
                        size: 12
                    },
                    xanchor: 'center',
                    yanchor: 'bottom'
                });
            }

            Plotly.newPlot('dist-plot', traces, layout);
            modal.style.display = "block";
        });

        function refreshScoreDistributionPlot() {
            if (!currentData) return;

            const scores = currentData.features.map(f => f.properties.score);
            const selectedScores = currentData.features
                .filter(f => f.properties.top500)
                .map(f => f.properties.score);

            // Get selected area scores if available
            let selectedAreaScores = [];
            if (selectedParcels && selectedParcels.length > 0) {
                selectedAreaScores = selectedParcels.map(f => f.properties.score);
            }

            // Calculate statistics for all scores
            const allScoresMean = scores.reduce((a, b) => a + b, 0) / scores.length;
            const allScoresMin = Math.min(...scores);
            const allScoresMax = Math.max(...scores);
            const allScoresStd = Math.sqrt(scores.reduce((a, b) => a + Math.pow(b - allScoresMean, 2), 0) / scores.length);

            // Calculate statistics for selected scores
            const selectedScoresMean = selectedScores.reduce((a, b) => a + b, 0) / selectedScores.length;
            const selectedScoresMin = Math.min(...selectedScores);
            const selectedScoresMax = Math.max(...selectedScores);
            const selectedScoresStd = Math.sqrt(selectedScores.reduce((a, b) => a + Math.pow(b - selectedScoresMean, 2), 0) / selectedScores.length);

            // Create main histogram for all scores to get the max height
            const allScoresTrace = {
                x: scores,
                type: 'histogram',
                name: 'All Parcels',
                marker: {
                    color: '#ff6666',
                    line: {
                        color: 'rgba(200,200,200,0.3)',
                        width: 1
                    }
                },
                nbinsx: 50,
                opacity: 0.7
            };

            const traces = [allScoresTrace];

            // Calculate the expected maximum height for reference bars (1/4 of plot height)
            const binCount = Math.ceil(scores.length / 50);
            const referenceBarHeight = binCount * 0.25;

            // Add selected area bars and arrows if available
            if (selectedAreaScores.length > 0) {
                const selectedAreaMean = selectedAreaScores.reduce((a, b) => a + b, 0) / selectedAreaScores.length;
                const selectedAreaMin = Math.min(...selectedAreaScores);
                const selectedAreaMax = Math.max(...selectedAreaScores);
                
                // Add dotted bars at min and max (1/4 height)
                traces.push({
                    x: [selectedAreaMin, selectedAreaMin],
                    y: [0, referenceBarHeight],
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        color: '#ffff00',
                        width: 3,
                        dash: 'dot'
                    },
                    name: `Selected Area Min: ${selectedAreaMin.toFixed(3)}`,
                    showlegend: true
                });

                traces.push({
                    x: [selectedAreaMax, selectedAreaMax],
                    y: [0, referenceBarHeight],
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        color: '#ffff00',
                        width: 3,
                        dash: 'dot'
                    },
                    name: `Selected Area Max: ${selectedAreaMax.toFixed(3)}`,
                    showlegend: true
                });

                // Add solid bar at mean (1/4 height)
                traces.push({
                    x: [selectedAreaMean, selectedAreaMean],
                    y: [0, referenceBarHeight],
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        color: '#ffff00',
                        width: 3
                    },
                    name: `Selected Area Mean: ${selectedAreaMean.toFixed(3)}`,
                    showlegend: true
                });
            }

            const layout = {
                title: 'Calculated Risk Score Distribution (Auto-Updated)',
                paper_bgcolor: '#1a1a1a',
                plot_bgcolor: '#1a1a1a',
                font: {
                    color: '#fff'
                },
                xaxis: {
                    title: 'Score',
                    gridcolor: 'rgba(255,255,255,0.1)',
                    zerolinecolor: 'rgba(255,255,255,0.1)'
                },
                yaxis: {
                    title: 'Count',
                    gridcolor: 'rgba(255,255,255,0.1)',
                    zerolinecolor: 'rgba(255,255,255,0.1)'
                },
                showlegend: true,
                legend: {
                    font: {
                        color: '#fff'
                    },
                    y: 0.95,
                    x: 0.02
                },
                bargap: 0,
                displayModeBar: false,
                margin: {
                    l: 50,
                    r: 20,
                    t: 50,
                    b: 50
                },
                height: 600,
                annotations: []
            };

            // Add statistics annotation
            let statsText = `All Parcels:<br>Min: ${allScoresMin.toFixed(3)}<br>Max: ${allScoresMax.toFixed(3)}<br>Mean: ${allScoresMean.toFixed(3)}<br>Std: ${allScoresStd.toFixed(3)}<br>Count: ${scores.length}<br><br>Top N Parcels:<br>Min: ${selectedScoresMin.toFixed(3)}<br>Max: ${selectedScoresMax.toFixed(3)}<br>Mean: ${selectedScoresMean.toFixed(3)}<br>Std: ${selectedScoresStd.toFixed(3)}<br>Count: ${selectedScores.length}`;
            
            if (selectedAreaScores.length > 0) {
                const selectedAreaMean = selectedAreaScores.reduce((a, b) => a + b, 0) / selectedAreaScores.length;
                const selectedAreaMin = Math.min(...selectedAreaScores);
                const selectedAreaMax = Math.max(...selectedAreaScores);
                const selectedAreaStd = Math.sqrt(selectedAreaScores.reduce((a, b) => a + Math.pow(b - selectedAreaMean, 2), 0) / selectedAreaScores.length);
                statsText += `<br><br>Selected Area:<br>Min: ${selectedAreaMin.toFixed(3)}<br>Max: ${selectedAreaMax.toFixed(3)}<br>Mean: ${selectedAreaMean.toFixed(3)}<br>Std: ${selectedAreaStd.toFixed(3)}<br>Count: ${selectedAreaScores.length}`;
            }

            layout.annotations.push({
                x: 0.02,
                y: 0.02,
                xref: 'paper',
                yref: 'paper',
                text: statsText,
                showarrow: false,
                font: {
                    color: '#fff',
                    size: 12
                },
                bgcolor: 'rgba(0,0,0,0.5)',
                bordercolor: 'rgba(255,255,255,0.3)',
                borderwidth: 1,
                borderpad: 4,
                xanchor: 'left',
                yanchor: 'bottom'
            });

            // Add single arrow for top parcels (blue arrow)
            const maxY = referenceBarHeight * 4;
            const arrowY = maxY * 0.9;
            
            // Add single arrow for Top Parcels at the midpoint of selected scores
            if (selectedScores.length > 0) {
                const topParcelsScore = selectedScores[Math.floor(selectedScores.length / 2)];
                layout.annotations.push({
                    x: topParcelsScore,
                    y: arrowY,
                    text: 'Top Parcels',
                    showarrow: true,
                    arrowhead: 2,
                    arrowsize: 1,
                    arrowwidth: 2,
                    arrowcolor: '#0066ff',
                    font: {
                        color: '#0066ff',
                        size: 12
                    },
                    xanchor: 'center',
                    yanchor: 'bottom'
                });
            }

            // Add arrows for selected area scores (yellow arrows for min, mean, max)
            if (selectedAreaScores.length > 0) {
                const selectedAreaMean = selectedAreaScores.reduce((a, b) => a + b, 0) / selectedAreaScores.length;
                const selectedAreaMin = Math.min(...selectedAreaScores);
                const selectedAreaMax = Math.max(...selectedAreaScores);
                
                const yellowArrowY = arrowY * 0.7;
                
                // Min arrow
                layout.annotations.push({
                    x: selectedAreaMin,
                    y: yellowArrowY,
                    text: 'Min',
                    showarrow: true,
                    arrowhead: 2,
                    arrowsize: 1,
                    arrowwidth: 2,
                    arrowcolor: '#ffff00',
                    font: {
                        color: '#ffff00',
                        size: 12
                    },
                    xanchor: 'center',
                    yanchor: 'bottom'
                });
                
                // Mean arrow
                layout.annotations.push({
                    x: selectedAreaMean,
                    y: yellowArrowY,
                    text: 'Mean',
                    showarrow: true,
                    arrowhead: 2,
                    arrowsize: 1,
                    arrowwidth: 2,
                    arrowcolor: '#ffff00',
                    font: {
                        color: '#ffff00',
                        size: 12
                    },
                    xanchor: 'center',
                    yanchor: 'bottom'
                });
                
                // Max arrow
                layout.annotations.push({
                    x: selectedAreaMax,
                    y: yellowArrowY,
                    text: 'Max',
                    showarrow: true,
                    arrowhead: 2,
                    arrowsize: 1,
                    arrowwidth: 2,
                    arrowcolor: '#ffff00',
                    font: {
                        color: '#ffff00',
                        size: 12
                    },
                    xanchor: 'center',
                    yanchor: 'bottom'
                });
            }

            Plotly.newPlot('dist-plot', traces, layout);
        }

        // Layer toggles
        document.querySelectorAll('.layer-toggle[data-layer="dark"], .layer-toggle[data-layer="light"], .layer-toggle[data-layer="satellite"]').forEach(toggle => {
            toggle.addEventListener('change', (e) => {
                if (e.target.checked) {
                    document.querySelectorAll('.layer-toggle[data-layer="dark"], .layer-toggle[data-layer="light"], .layer-toggle[data-layer="satellite"]').forEach(t => {
                        if (t !== e.target) t.checked = false;
                    });
                    
                    const styleMap = {
                        'dark': 'mapbox://styles/mapbox/dark-v11',
                        'light': 'mapbox://styles/mapbox/light-v11',
                        'satellite': 'mapbox://styles/mapbox/satellite-streets-v12'
                    };
                    map.setStyle(styleMap[e.target.dataset.layer]);
                    
                    map.once('style.load', () => {
                        initializeLayers();
                    });
                }
            });
        });
        
        document.querySelectorAll('.layer-toggle[data-layer]:not([data-layer="dark"]):not([data-layer="light"]):not([data-layer="satellite"])').forEach(toggle => {
            toggle.addEventListener('change', (e) => {
                const layerId = e.target.dataset.layer;
                const visibility = e.target.checked ? 'visible' : 'none';
                
                if (layerId === 'parcels') {
                    if (map.getLayer('parcels-fill')) {
                        map.setLayoutProperty('parcels-fill', 'visibility', visibility);
                    }
                    if (map.getLayer('parcels-top500')) {
                        map.setLayoutProperty('parcels-top500', 'visibility', visibility);
                    }
                } else if (layerId === 'burnscars') {
                    if (map.getLayer('burnscars')) {
                        map.setLayoutProperty('burnscars', 'visibility', visibility);
                    }
                    if (map.getLayer('burnscars-outline')) {
                        map.setLayoutProperty('burnscars-outline', 'visibility', visibility);
                    }
                } else if (map.getLayer(layerId)) {
                    map.setLayoutProperty(layerId, 'visibility', visibility);
                }
            });
        });

        // Modal controls
        closeModal.onclick = function() {
            modal.style.display = "none";
        }
        
        // Close solution modal
        document.getElementById('close-solution-modal').addEventListener('click', () => {
            document.getElementById('solution-modal').style.display = 'none';
        });
        
        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = "none";
            }
            // Close solution modal when clicking outside of it
            const solutionModal = document.getElementById('solution-modal');
            if (event.target === solutionModal) {
                solutionModal.style.display = 'none';
            }
        }

        // Measure tool
        measureButton.addEventListener('click', () => {
            measureMode = !measureMode;
            measureButton.textContent = measureMode ? 'Cancel Measurement' : 'Measure Distance';
            
            if (!measureMode) {
                exitMeasureMode();
            }
        });

        // Map event handlers
        map.on('draw.create', (e) => {
            const selection = e.features[0];
            
            // Check if this is a subset area selection
            if (document.getElementById('subset-rectangle').dataset.mode === 'subset' || 
                document.getElementById('subset-lasso').dataset.mode === 'subset') {
                subsetArea = selection.geometry;
                document.getElementById('filter-parcels').disabled = false;
                
                // Reset modes
                document.getElementById('subset-rectangle').dataset.mode = '';
                document.getElementById('subset-lasso').dataset.mode = '';
            } 
            // Check if this is multi-area selection for weight inference
            else if (isAddingSelection) {
                const drawMode = draw.getMode();
                const selectionType = drawMode === 'draw_rectangle' ? 'rectangle' : 'lasso';
                
                // Add to selection areas with the feature ID for tracking
                const featureId = selection.id;
                addSelectionArea(selection.geometry, selectionType, featureId);
                
                // Keep the drawn feature visible (don't delete)
                // Reset selection mode to simple_select so user can draw more
                isAddingSelection = false;
                draw.changeMode('simple_select');
                
                console.log(`Added ${selectionType} to selection areas. Total: ${selectionAreas.length}`);
            } 
            // Legacy single selection (kept for compatibility)
            else {
                // Regular single selection for weight inference (legacy mode)
                document.getElementById('infer-weights').disabled = false;
                
                if (currentData && window.turf) {
                    selectedParcels = currentData.features.filter(feature => {
                        return turf.booleanIntersects(feature, selection);
                    });
                    
                    const selectedCount = selectedParcels.length;
                    const totalRisk = selectedParcels.reduce((sum, f) => sum + f.properties.score, 0);
                    const avgRisk = selectedCount > 0 ? totalRisk / selectedCount : 0;
                    
                    document.getElementById('selected-parcels').textContent = selectedCount.toLocaleString();
                    document.getElementById('total-risk').textContent = totalRisk.toFixed(2);
                    document.getElementById('avg-risk').textContent = avgRisk.toFixed(2);
                }
            }
        });

        function resetInferWeightsUI() {
            document.getElementById('infer-weights').disabled = true;
            document.getElementById('download-lp-btn').disabled = true;
            document.getElementById('view-solution-btn').disabled = true;
            currentLpContent = null;
            currentTxtContent = null;
        }

        map.on('draw.delete', () => {
            selectedParcels = [];
            resetInferWeightsUI();
            
            // If no shapes remain, disable filter button and clear subset area
            const features = draw.getAll().features;
            if (features.length === 0) {
                document.getElementById('filter-parcels').disabled = true;
                subsetArea = null;
                document.getElementById('subset-indicator').style.display = 'none';
            }
        });

        map.on('click', (e) => {
            if (measureMode) {
                measurePoints.push([e.lngLat.lng, e.lngLat.lat]);

                if (measurePoints.length === 1) {
                    if (map.getSource('measure-line')) {
                        map.removeLayer('measure-line');
                        map.removeSource('measure-line');
                    }
                    map.addSource('measure-line', {
                        type: 'geojson',
                        data: {
                            type: 'Feature',
                            properties: {},
                            geometry: {
                                type: 'LineString',
                                coordinates: measurePoints
                            }
                        }
                    });
                    map.addLayer({
                        id: 'measure-line',
                        type: 'line',
                        source: 'measure-line',
                        layout: {
                            'line-cap': 'round',
                            'line-join': 'round'
                        },
                        paint: {
                            'line-color': '#fff',
                            'line-width': 2,
                            'line-dasharray': [2, 2]
                        }
                    });
                } else {
                    const line = {
                        type: 'Feature',
                        properties: {},
                        geometry: {
                            type: 'LineString',
                            coordinates: measurePoints
                        }
                    };
                    map.getSource('measure-line').setData(line);

                    const distance = turf.length(line) * 3280.84;
                    document.getElementById('distance').textContent = `Total distance: ${distance.toFixed(0)} ft`;
                }
            }
        });

        map.on('mousemove', (e) => {
            if (!measureMode || measurePoints.length === 0) return;

            const line = {
                type: 'Feature',
                properties: {},
                geometry: {
                    type: 'LineString',
                    coordinates: [...measurePoints, [e.lngLat.lng, e.lngLat.lat]]
                }
            };
            map.getSource('measure-line').setData(line);

            if (measurePoints.length > 0) {
                const distance = turf.length(line) * 3280.84;
                document.getElementById('distance').textContent = `Total distance: ${distance.toFixed(0)} ft`;
            }
        });

        map.on('contextmenu', (e) => {
            if (!measureMode) return;
            e.preventDefault();
            exitMeasureMode();
        });

        map.on('click', 'parcels-fill', (e) => {
            if (measureMode || draw.getMode() === 'draw_rectangle' || draw.getMode() === 'draw_lasso') {
                return;
            }
            
            const props = e.features[0].properties;
            new mapboxgl.Popup()
                .setLngLat(e.lngLat)
                .setHTML(createPopupContent(props))
                .addTo(map);
        });
        
        map.on('mouseenter', 'parcels-fill', () => {
            if (draw.getMode() !== 'draw_rectangle' && draw.getMode() !== 'draw_lasso' && !measureMode) {
                map.getCanvas().style.cursor = 'pointer';
            }
        });
        
        map.on('mouseleave', 'parcels-fill', () => {
            if (draw.getMode() !== 'draw_rectangle' && draw.getMode() !== 'draw_lasso' && !measureMode) {
                map.getCanvas().style.cursor = '';
            }
        });

        // Burnscars click handler
        map.on('click', 'burnscars', (e) => {
            if (measureMode || draw.getMode() === 'draw_rectangle' || draw.getMode() === 'draw_lasso') {
                return;
            }
            
            const props = e.features[0].properties;
            new mapboxgl.Popup()
                .setLngLat(e.lngLat)
                .setHTML(createBurnscarPopupContent(props))
                .addTo(map);
        });
        
        map.on('mouseenter', 'burnscars', () => {
            if (draw.getMode() !== 'draw_rectangle' && draw.getMode() !== 'draw_lasso' && !measureMode) {
                map.getCanvas().style.cursor = 'pointer';
            }
        });
        
        map.on('mouseleave', 'burnscars', () => {
            if (draw.getMode() !== 'draw_rectangle' && draw.getMode() !== 'draw_lasso' && !measureMode) {
                map.getCanvas().style.cursor = '';
            }
        });

        // Initialize layers function
        function initializeLayers() {
            map.addSource('parcels', {
                type: 'geojson',
                data: currentData || { type: 'FeatureCollection', features: [] }
            });
            
            map.addLayer({
                id: 'parcels-fill',
                type: 'fill',
                source: 'parcels',
                paint: {
                    'fill-color': [
                        'interpolate',
                        ['linear'],
                        ['get', 'score'],
                        0, '#ffffff',
                        0.2, '#ffdddd',
                        0.4, '#ffaaaa',
                        0.6, '#ff6666',
                        0.8, '#ff3333',
                        1, '#990000'
                    ],
                    'fill-opacity': 0.8
                }
            });
            
            map.addLayer({
                id: 'parcels-boundary',
                type: 'line',
                source: 'parcels',
                minzoom: 14,
                paint: {
                    'line-color': '#ffffff',
                    'line-width': 0.5,
                    'line-opacity': 0.3
                }
            });
            
            map.addLayer({
                id: 'parcels-top500',
                type: 'line',
                source: 'parcels',
                filter: ['==', ['get', 'top500'], true],
                paint: {
                    'line-color': '#0066ff',
                    'line-width': 2
                }
            });
            
            const auxiliaryLayers = [
                {
                    id: 'agricultural',
                    type: 'fill',
                    paint: {
                        'fill-color': '#00ff00',
                        'fill-opacity': 0.5
                    }
                },
                {
                    id: 'fuelbreaks',
                    type: 'fill',
                    paint: {
                        'fill-color': '#00ff00',
                        'fill-opacity': 0.5
                    }
                },
                {
                    id: 'wui',
                    type: 'fill',
                    paint: {
                        'fill-color': '#0066ff',
                        'fill-opacity': 0.5
                    }
                },
                {
                    id: 'hazard',
                    type: 'fill',
                    paint: {
                        'fill-color': '#ff9900',
                        'fill-opacity': 0.25
                    }
                },
                {
                    id: 'structures',
                    type: 'fill',
                    paint: {
                        'fill-color': '#000000',
                        'fill-opacity': 0.5
                    }
                },
                {
                    id: 'firewise',
                    type: 'line',
                    paint: {
                        'line-color': '#ff9900',
                        'line-width': 2
                    }
                },
                {
                    id: 'burnscars',
                    type: 'fill',
                    paint: {
                        'fill-color': '#ffcc99',
                        'fill-opacity': 0.3,
                        'fill-outline-color': '#cc7722'
                    }
                }
            ];

            auxiliaryLayers.forEach(layer => {
                map.addSource(layer.id, {
                    type: 'geojson',
                    data: { type: 'FeatureCollection', features: [] }
                });
                
                map.addLayer({
                    id: layer.id,
                    type: layer.type,
                    source: layer.id,
                    layout: { 'visibility': 'none' },
                    paint: layer.paint
                });
                
                // Add outline layer for burn scars
                if (layer.id === 'burnscars') {
                    map.addLayer({
                        id: 'burnscars-outline',
                        type: 'line',
                        source: layer.id,
                        layout: { 'visibility': 'none' },
                        paint: {
                            'line-color': '#cc7722',
                            'line-width': 1.0
                        }
                    });
                }
                
                loadLayer(layer.id);
            });

            if (currentData) {
                updateMap();
            } else {
                updateScores(true);  // Initial load is like a filter change
            }
        }

        // Map load
        map.on('load', () => {
            initializeLayers();
            normalizeWeights();
            updateMaxParcels();
            updateSelectionCount(); // Initialize multi-area selection UI
            updateScores(true);  // Initial load is like a filter change
            
            document.querySelectorAll('input[type="range"]').forEach(slider => {
                updateSliderFill(slider);
            });
        });

        // Add distribution buttons to sliders
        document.querySelectorAll('.slider-container').forEach(container => {
            const slider = container.querySelector('.slider');
            const variable = slider.id;
            const rawVariable = rawVarMap[variable] || variable.replace('_s', '');
            
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'dist-buttons';
            
            const rawButton = document.createElement('button');
            rawButton.className = 'dist-button';
            rawButton.textContent = 'Raw Distribution';
            rawButton.onclick = () => showDistribution(rawVariable);
            
            const scoreButton = document.createElement('button');
            scoreButton.className = 'dist-button';
            scoreButton.textContent = 'Score Distribution';
            scoreButton.onclick = () => showDistribution(variable);
            
            buttonContainer.appendChild(rawButton);
            buttonContainer.appendChild(scoreButton);
            container.appendChild(buttonContainer);
        });

        // Global keyboard handler
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Don't handle Escape if we're in drawing mode - let the drawing tool handle it
                const currentMode = draw.getMode();
                if (currentMode === 'draw_lasso' || currentMode === 'draw_rectangle') {
                    return;
                }
                
                if (measureMode) {
                    exitMeasureMode();
                }
                // Close solution modal if open
                const solutionModal = document.getElementById('solution-modal');
                if (solutionModal.style.display === 'block') {
                    solutionModal.style.display = 'none';
                }
            }
        });

        // Add event listeners for exclude checkboxes
        document.querySelectorAll('.exclude-weight').forEach(checkbox => {
            checkbox.addEventListener('change', (e) => {
                const sliderId = e.target.id.replace('exclude-', '');
                const slider = document.getElementById(sliderId);
                const valueDisplay = document.getElementById(`${sliderId}-value`);
                
                if (e.target.checked) {
                    // Store the current value before setting to 0
                    slider.dataset.previousValue = slider.value;
                    slider.value = 0;
                    slider.classList.add('disabled');
                    valueDisplay.textContent = '0%';
                } else {
                    // Restore the previous value
                    const previousValue = slider.dataset.previousValue || 0;
                    slider.value = previousValue;
                    slider.classList.remove('disabled');
                    // Update the slider fill visual
                    updateSliderFill(slider);
                }
                
                // Always renormalize weights
                normalizeWeights();
                
                // Check if there's an active weight inference selection
                const inferWeightsBtn = document.getElementById('infer-weights');
                const hasActiveSelection = !inferWeightsBtn.disabled;
                
                if (hasActiveSelection && draw.getAll().features.length > 0) {
                    // Automatically rerun weight inference with updated exclude settings
                    console.log('Rerunning weight inference due to exclude variable change');
                    inferWeightsBtn.click();
                } else {
                    // No active weight inference selection, just update scores normally
                    updateScores(false);  // Weight change, not filter change
                }
            });
        });

        // Load Turf.js
        const script = document.createElement('script');
        script.src = 'https://unpkg.com/@turf/turf@6/turf.min.js';
        document.head.appendChild(script);
    </script>
</body>
</html>