<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fire Risk Calculator</title>
    <script src='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css' rel='stylesheet' />
    <script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.0/mapbox-gl-draw.js'></script>
    <link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.0/mapbox-gl-draw.css' type='text/css' />
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <script src="{{ url_for('static', filename='welcome-popup.js') }}"></script>
    <script src="{{ url_for('static', filename='js/client-filtering.js') }}"></script>
    <script src="{{ url_for('static', filename='js/client-scoring.js') }}"></script>
    <script src="{{ url_for('static', filename='js/plotting.js') }}"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        
        #map { 
            position: absolute; 
            top: 0; 
            bottom: 0; 
            width: 100%; 
        }
        
        /* Main control panel */
        .control-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(26, 26, 26, 0.95);
            padding: 0;
            border-radius: 4px;
            width: 320px;
            max-height: calc(100vh - 60px);
            overflow-y: auto;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease;
        }
        
        .control-panel.collapsed {
            transform: translateX(-310px);
        }
        
        /* WRI Logo Header */
        .wri-header {
            background: #1e6091;
            padding: 10px 15px;
            border-radius: 4px 4px 0 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .wri-logo-link {
            display: flex;
            align-items: center;
            text-decoration: none;
            flex: 1;
        }
        
        .wri-logo {
            height: 40px;
            width: auto;
        }
        
        .hamburger-menu {
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 5px;
            margin-left: 10px;
            border-radius: 3px;
            transition: background-color 0.3s;
        }
        
        .hamburger-menu:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        /* Toggle button for collapsed panel */
        .panel-toggle {
            position: absolute;
            top: 10px;
            left: 20px;
            background: #1e6091;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 10px 12px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            z-index: 1001;
            display: none;
            transition: background-color 0.3s;
        }
        
        .panel-toggle:hover {
            background: #2574a0;
        }
        
        .panel-toggle.show {
            display: block;
        }
        
        /* Panel content */
        .panel-content {
            padding: 15px;
        }
        
        .control-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        .control-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .control-panel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }
        
        h1 {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 15px;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .help-btn {
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s;
        }
        
        .help-btn:hover {
            background: #45a049;
        }
        
        h2 {
            font-size: 13px;
            font-weight: 600;
            color: #fff;
            margin: 15px 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Section styling */
        .control-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        /* Slider styling */
        .slider-container {
            margin: 6px 0;
        }
        
        .slider-label {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            margin-bottom: 3px;
            font-size: 12px;
            color: #ccc;
        }

        .exclude-weight {
            margin-left: 8px;
            accent-color: #ff6666;
        }
        
        .slider-value {
            color: #fff;
            font-weight: 500;
            min-width: 45px;
            text-align: right;
        }
        
        .slider {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            outline: none;
            cursor: pointer;
            border-radius: 2px;
            margin: 8px 0;
        }
        
        .slider::-webkit-slider-track {
            width: 100%;
            height: 4px;
            border-radius: 2px;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }
        
        .slider::-moz-range-track {
            width: 100%;
            height: 4px;
            border-radius: 2px;
        }
        
        .slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #fff;
            cursor: pointer;
            border-radius: 50%;
            border: none;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
        }
        
        .slider::-moz-range-thumb:hover {
            transform: scale(1.2);
        }
        
        .slider::-moz-range-progress {
            background: #4a90e2;
            height: 4px;
            border-radius: 2px;
        }
        
        /* Toggle/Checkbox styling */
        .toggle-container {
            margin: 8px 0;
        }
        
        .toggle-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 12px;
            color: #ccc;
            padding: 4px 0;
        }
        
        .toggle-label:hover {
            color: #fff;
        }
        
        .toggle-label input[type="checkbox"],
        .toggle-label input[type="radio"] {
            width: 14px;
            height: 14px;
            margin-right: 8px;
            cursor: pointer;
            accent-color: #4CAF50;
        }

        /* Variable enable/disable styling */
        .variable-container {
            margin: 6px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            padding: 6px;
            transition: all 0.3s ease;
        }

        .variable-header {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
        }

        .variable-enable-checkbox {
            width: 14px;
            height: 14px;
            margin-right: 8px;
            cursor: pointer;
            accent-color: #4CAF50;
        }

        .variable-name {
            font-size: 11px;
            color: #ccc;
            font-weight: 500;
            flex: 1;
        }

        .variable-controls {
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .variable-controls.collapsed {
            max-height: 0;
            opacity: 0;
            margin: 0;
            padding: 0;
        }

        .variable-controls.expanded {
            max-height: 120px;
            opacity: 1;
        }

        .variable-container.disabled {
            opacity: 0.6;
            background: rgba(255, 255, 255, 0.02);
        }

        .variable-container.disabled .variable-name {
            color: #888;
        }
        
        /* Button styling */
        .button {
            background: #333;
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            text-align: center;
            font-size: 12px;
            cursor: pointer;
            border-radius: 3px;
            width: 100%;
            transition: all 0.2s;
            margin: 4px 0;
        }
        
        .button:hover:not(:disabled) {
            background: #444;
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .button.primary {
            background: #4CAF50;
            border-color: #4CAF50;
        }
        
        .button.primary:hover:not(:disabled) {
            background: #45a049;
            border-color: #45a049;
        }

        .button.small {
            padding: 4px 8px;
            font-size: 10px;
            font-weight: 500;
        }
        
        /* Input styling */
        .input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
        }
        
        .input-group label {
            font-size: 12px;
            color: #ccc;
            flex: 1;
        }
        
        .number-input {
            width: 80px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            color: #fff;
            font-size: 12px;
        }
        
        .number-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.4);
            background: rgba(255, 255, 255, 0.15);
        }
        
        /* Stats display */
        .stats {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 3px;
            font-size: 11px;
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .stats-row {
            display: flex;
            justify-content: space-between;
            color: #aaa;
        }
        
        .stats-value {
            color: #fff;
            font-weight: 500;
        }
        
        /* Legend styling */
        .legend {
            position: absolute;
            bottom: 20px;
            right: 10px;
            background: rgba(26, 26, 26, 0.95);
            padding: 12px;
            border-radius: 4px;
            font-size: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        .legend-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #fff;
        }
        
        .legend-gradient {
            height: 15px;
            background: linear-gradient(to right, #ffffff 0%, #ffcccc 25%, #ff6666 50%, #ff0000 75%, #990000 100%);
            border-radius: 2px;
            margin: 8px 0;
        }
        
        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #aaa;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 11px;
            color: #ccc;
        }
        
        .legend-box {
            width: 16px;
            height: 3px;
            margin-right: 8px;
            border: 2px solid #0066ff;
            border-radius: 1px;
        }
        

        
        /* Popup styling */
        .mapboxgl-popup-content {
            background: rgba(26, 26, 26, 0.95);
            color: #e0e0e0;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        .mapboxgl-popup-content h3 {
            margin: 0 0 8px 0;
            font-size: 13px;
            color: #fff;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 5px;
        }
        
        .mapboxgl-popup-content p {
            margin: 3px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .mapboxgl-popup-content strong {
            color: #aaa;
            font-weight: normal;
        }
        
        .mapboxgl-popup-close-button {
            color: #fff;
            font-size: 16px;
            padding: 4px 8px;
        }
        
        .mapboxgl-popup-close-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .mapboxgl-popup-anchor-top .mapboxgl-popup-tip {
            border-bottom-color: rgba(26, 26, 26, 0.95);
        }
        
        /* Add spinner styles */
        .spinner-container {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #4a90e2;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        .spinner-text {
            color: #4a90e2;
            margin-top: 10px;
            text-align: center;
            font-size: 14px;
            font-weight: 500;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Distribution plot button styling */
        .dist-button {
            background: #444;
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            border-radius: 3px;
            margin: 2px;
            transition: all 0.2s;
        }
        
        .dist-button:hover {
            background: #555;
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .dist-buttons {
            display: flex;
            justify-content: flex-end;
            margin-top: 4px;
        }
        
        /* Modal styling */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
        }
        
        .modal-content {
            background-color: #1a1a1a;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.2);
            width: 80%;
            max-width: 800px;
            border-radius: 4px;
        }
        
        .close-modal {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close-modal:hover {
            color: #fff;
        }
        
        /* Measure tool styling */
        .measure-container {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1;
            background: rgba(26, 26, 26, 0.95);
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .distance-container {
            color: #fff;
            font-size: 12px;
            line-height: 18px;
            margin: 0;
            padding: 5px 10px;
            border-radius: 3px;
        }

        .filter-group {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .filter-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            min-width: 150px;
        }

        .filter-group select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
            background-color: #fff;
            color: #333;
        }

        .filter-group select:disabled {
            background-color: #f5f5f5;
            color: #999;
        }

        .slider.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <!-- Add spinner HTML -->
    <div class="spinner-container" id="spinner">
        <div class="spinner"></div>
        <div class="spinner-text">Calculating...</div>
    </div>
    
    <!-- Toggle button for when panel is collapsed -->
    <button class="panel-toggle" id="panel-toggle" onclick="togglePanel()">☰</button>
    
    <div class="control-panel" id="control-panel">
        <!-- WRI Logo Header -->
        <div class="wri-header">
            <a href="https://wri.ucsb.edu/" target="_blank" class="wri-logo-link">
                <img src="https://webapp.wri.ucsb.edu/wrilogo_1.png" alt="WRI Logo" class="wri-logo">
            </a>
            <button class="hamburger-menu" onclick="togglePanel()" title="Collapse Panel">☰</button>
        </div>
        
        <!-- Panel Content -->
        <div class="panel-content">
            <h1>Fire Risk Calculator <button class="help-btn" onclick="WelcomePopup.showWelcome()" title="Show Tutorial">?</button></h1>
        
        <div class="control-section">
            <h2>Risk Factor Weights</h2>
            <div id="weight-sliders">
                <!-- Structure Density Group -->
                <div class="variable-container" data-variable="qtrmi_s">
                    <div class="variable-header">
                        <input type="checkbox" class="variable-enable-checkbox" id="enable-qtrmi_s" checked>
                        <span class="variable-name">Number of Structures Within Window (1/4 mile)</span>
                    </div>
                    <div class="variable-controls expanded">
                        <div class="slider-container">
                            <div class="slider-label">
                                <span class="slider-value" id="qtrmi_s-value">30%</span>
                            </div>
                            <input type="range" class="slider weight-slider" id="qtrmi_s" min="0" max="100" value="30">
                            <div class="dist-buttons">
                                <button class="dist-button" onclick="window.plottingManager.showDistribution('qtrmi_cnt')">Raw</button>
                                <button class="dist-button" onclick="window.plottingManager.showDistribution('qtrmi_s')">Score</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="variable-container" data-variable="neigh1d_s">
                    <div class="variable-header">
                        <input type="checkbox" class="variable-enable-checkbox" id="enable-neigh1d_s" checked>
                        <span class="variable-name">Distance to Nearest Neighbor</span>
                    </div>
                    <div class="variable-controls expanded">
                        <div style="font-size: 10px; color: #888; margin-bottom: 3px;">Only Includes Parcels with Structure Data</div>
                        <div class="slider-container">
                            <div class="slider-label">
                                <span class="slider-value" id="neigh1d_s-value">0%</span>
                            </div>
                            <input type="range" class="slider weight-slider" id="neigh1d_s" min="0" max="100" value="0">
                            <div class="dist-buttons">
                                <button class="dist-button" onclick="window.plottingManager.showDistribution('neigh1_d')">Raw</button>
                                <button class="dist-button" onclick="window.plottingManager.showDistribution('neigh1d_s')">Score</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- WUI & Hazards Group -->
                <div class="variable-container" data-variable="hwui_s">
                    <div class="variable-header">
                        <input type="checkbox" class="variable-enable-checkbox" id="enable-hwui_s" checked>
                        <span class="variable-name">WUI coverage percentage (1/2 mile)</span>
                    </div>
                    <div class="variable-controls expanded">
                        <div class="slider-container">
                            <div class="slider-label">
                                <span class="slider-value" id="hwui_s-value">10%</span>
                            </div>
                            <input type="range" class="slider weight-slider" id="hwui_s" min="0" max="100" value="10">
                            <div class="dist-buttons">
                                <button class="dist-button" onclick="window.plottingManager.showDistribution('hlfmi_wui')">Raw</button>
                                <button class="dist-button" onclick="window.plottingManager.showDistribution('hwui_s')">Score</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="variable-container" data-variable="hvhsz_s">
                    <div class="variable-header">
                        <input type="checkbox" class="variable-enable-checkbox" id="enable-hvhsz_s" checked>
                        <span class="variable-name">Very High Fire Hazard Zone coverage (1/2 mile)</span>
                    </div>
                    <div class="variable-controls expanded">
                        <div class="slider-container">
                            <div class="slider-label">
                                <span class="slider-value" id="hvhsz_s-value">30%</span>
                            </div>
                            <input type="range" class="slider weight-slider" id="hvhsz_s" min="0" max="100" value="30">
                            <div class="dist-buttons">
                                <button class="dist-button" onclick="window.plottingManager.showDistribution('hlfmi_vhsz')">Raw</button>
                                <button class="dist-button" onclick="window.plottingManager.showDistribution('hvhsz_s')">Score</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Agriculture & Fuelbreaks Group -->
                <div class="variable-container" data-variable="hlfmi_agfb_s">
                    <div class="variable-header">
                        <input type="checkbox" class="variable-enable-checkbox" id="enable-hlfmi_agfb_s" checked>
                        <span class="variable-name">Agriculture & Fuelbreaks (1/2 mile)</span>
                    </div>
                    <div class="variable-controls expanded">
                        <div class="slider-container">
                            <div class="slider-label">
                                <span class="slider-value" id="hlfmi_agfb_s-value">0%</span>
                            </div>
                            <input type="range" class="slider weight-slider" id="hlfmi_agfb_s" min="0" max="100" value="0">
                            <div class="dist-buttons">
                                <button class="dist-button" onclick="window.plottingManager.showDistribution('hlfmi_agfb')">Raw</button>
                                <button class="dist-button" onclick="window.plottingManager.showDistribution('hlfmi_agfb_s')">Score</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Slope Group -->
                <div class="variable-container" data-variable="par_buf_sl_s">
                    <div class="variable-header">
                        <input type="checkbox" class="variable-enable-checkbox" id="enable-par_buf_sl_s" checked>
                        <span class="variable-name">Structure Surrounding Slope (100 foot buffer)</span>
                    </div>
                    <div class="variable-controls expanded">
                        <div class="slider-container">
                            <div class="slider-label">
                                <span class="slider-value" id="par_buf_sl_s-value">0%</span>
                            </div>
                            <input type="range" class="slider weight-slider" id="par_buf_sl_s" min="0" max="100" value="0">
                            <div class="dist-buttons">
                                <button class="dist-button" onclick="window.plottingManager.showDistribution('par_buf_sl')">Raw</button>
                                <button class="dist-button" onclick="window.plottingManager.showDistribution('par_buf_sl_s')">Score</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Variables Turned Off (at bottom) -->
                <div class="variable-container" data-variable="hagri_s">
                    <div class="variable-header">
                        <input type="checkbox" class="variable-enable-checkbox" id="enable-hagri_s">
                        <span class="variable-name">Agricultural Coverage (1/2 Mile)</span>
                    </div>
                    <div class="variable-controls collapsed">
                        <div class="slider-container">
                            <div class="slider-label">
                                <span class="slider-value" id="hagri_s-value">0%</span>
                            </div>
                            <input type="range" class="slider weight-slider" id="hagri_s" min="0" max="100" value="0">
                            <div class="dist-buttons">
                                <button class="dist-button" onclick="window.plottingManager.showDistribution('hlfmi_agri')">Raw</button>
                                <button class="dist-button" onclick="window.plottingManager.showDistribution('hagri_s')">Score</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="variable-container" data-variable="hfb_s">
                    <div class="variable-header">
                        <input type="checkbox" class="variable-enable-checkbox" id="enable-hfb_s">
                        <span class="variable-name">Fuel Break coverage (1/2 mile)</span>
                    </div>
                    <div class="variable-controls collapsed">
                        <div class="slider-container">
                            <div class="slider-label">
                                <span class="slider-value" id="hfb_s-value">0%</span>
                            </div>
                            <input type="range" class="slider weight-slider" id="hfb_s" min="0" max="100" value="0">
                            <div class="dist-buttons">
                                <button class="dist-button" onclick="window.plottingManager.showDistribution('hlfmi_fb')">Raw</button>
                                <button class="dist-button" onclick="window.plottingManager.showDistribution('hfb_s')">Score</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="variable-container" data-variable="hbrn_s">
                    <div class="variable-header">
                        <input type="checkbox" class="variable-enable-checkbox" id="enable-hbrn_s">
                        <span class="variable-name">Burn Scar Coverage (1/2 mile)</span>
                    </div>
                    <div class="variable-controls collapsed">
                        <div class="slider-container">
                            <div class="slider-label">
                                <span class="slider-value" id="hbrn_s-value">0%</span>
                            </div>
                            <input type="range" class="slider weight-slider" id="hbrn_s" min="0" max="100" value="0">
                            <div class="dist-buttons">
                                <button class="dist-button" onclick="window.plottingManager.showDistribution('hlfmi_brn')">Raw</button>
                                <button class="dist-button" onclick="window.plottingManager.showDistribution('hbrn_s')">Score</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="variable-container" data-variable="slope_s">
                    <div class="variable-header">
                        <input type="checkbox" class="variable-enable-checkbox" id="enable-slope_s">
                        <span class="variable-name">Mean Parcel Slope</span>
                    </div>
                    <div class="variable-controls collapsed">
                        <div class="slider-container">
                            <div class="slider-label">
                                <span class="slider-value" id="slope_s-value">0%</span>
                            </div>
                            <input type="range" class="slider weight-slider" id="slope_s" min="0" max="100" value="0">
                            <div class="dist-buttons">
                                <button class="dist-button" onclick="window.plottingManager.showDistribution('slope_s')">Raw</button>
                                <button class="dist-button" onclick="window.plottingManager.showDistribution('slope_s')">Score</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div style="text-align: right; margin-top: 15px;">
                    <span style="font-size: 11px; color: #888;">Max Parcels: <span id="max-parcels-value">500</span></span>
                </div>
            </div>
        </div>
        
        <div class="control-section">
            <h2>Calculations</h2>
            <div class="input-group">
                <label>Parcels for Selection</label>
                <input type="number" class="number-input" id="max-parcels" value="500" min="1" max="5000">
            </div>
            <button class="button primary" id="calculate-btn">Calculate</button>
            <div style="text-align: right; margin-top: 5px;">
                <span style="font-size: 11px; color: #888;">Parcels for Selection: <span id="max-parcels-value">500</span></span>
            </div>
            
            <!-- Results - Collapsible -->
            <div style="margin-top: 15px;">
                <div style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;" id="results-header">
                    <span style="font-size: 12px; color: #aaa; font-weight: 600;">Results & Analysis</span>
                    <span style="margin-left: 8px; font-size: 12px; color: #888;" id="results-toggle">▶</span>
                </div>
                <div id="results-content" style="display: none; margin-left: 12px; padding-left: 8px; border-left: 2px solid rgba(255,255,255,0.1);">
                    <div class="stats">
                        <div class="stats-row">
                            <span>Total Parcels:</span>
                            <span class="stats-value" id="total-parcels">56308</span>
                        </div>
                        <div class="stats-row">
                            <span>Selected:</span>
                            <span class="stats-value" id="selected-parcels">500</span>
                        </div>
                        <div class="stats-row">
                            <span>Total Risk:</span>
                            <span class="stats-value" id="total-risk">408.88</span>
                        </div>
                        <div class="stats-row">
                            <span>Avg Risk:</span>
                            <span class="stats-value" id="avg-risk">0.82</span>
                        </div>
                        <div class="stats-row" id="normalization-row" style="display: none;">
                            <span>Normalization:</span>
                            <span class="stats-value" id="normalization-mode">Global</span>
                        </div>
                    </div>
                    <button class="button" id="export-shapefile" style="margin: 8px 0;">Export Shapefile</button>
                    <button class="button" id="score-distribution-btn" style="margin-bottom: 8px;">Calculated Risk Score Distribution</button>
                    <button class="button" id="show-correlation-matrix" style="margin-bottom: 8px;">Variable Correlation Matrix</button>
                </div>
            </div>
        </div>
        
        <div class="control-section">
            <h2>Spatial Filter</h2>
            <p style="font-size: 11px; color: #aaa; margin-bottom: 10px;">Draw an area to only show parcels within that boundary</p>
            <button class="button" id="subset-rectangle">Draw Rectangle</button>
            <button class="button" id="subset-lasso">Draw Lasso</button>
            <button class="button" id="clear-subset">Clear Filter</button>
            <button class="button primary" id="filter-parcels" disabled>Filter Parcels</button>
            <div id="subset-indicator" style="font-size: 11px; color: #4CAF50; margin-top: 8px; display: none;">
                ✓ Spatial filter active
            </div>
        </div>
        
        <div class="control-section">
            <div style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;" id="filters-header">
                <h2 style="margin: 0;">Filters</h2>
                <span style="margin-left: 8px; font-size: 12px; color: #888;" id="filters-toggle">▶</span>
            </div>
            <div id="filters-content" style="display: none; margin-left: 12px; padding-left: 8px; border-left: 2px solid rgba(255,255,255,0.1);">
                <!-- Advanced Score Options - Expandable -->
                <div style="margin-bottom: 15px;">
                    <div style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;" id="advanced-score-header">
                        <span style="font-size: 12px; color: #aaa; font-weight: 600;">Advanced Score Options</span>
                        <span style="margin-left: 8px; font-size: 12px; color: #888;" id="advanced-score-toggle">▶</span>
                    </div>
                    <div id="advanced-score-content" style="display: none; margin-left: 12px; padding-left: 8px; border-left: 2px solid rgba(255,255,255,0.1);">
                        <div style="margin-bottom: 10px;">
                            <h4 style="font-size: 11px; color: #aaa; margin-bottom: 6px;">Score Type:</h4>
                            <div class="toggle-container">
                                <label class="toggle-label">
                                    <input type="radio" name="score-type" id="use-basic-scores" value="basic" checked>
                                    Basic Min-Max Scores
                                </label>
                            </div>
                            <div class="toggle-container">
                                <label class="toggle-label">
                                    <input type="radio" name="score-type" id="use-quantile" value="quantile">
                                    Quantile Scores
                                </label>
                            </div>
                        </div>
                        <div>
                            <h4 style="font-size: 11px; color: #aaa; margin-bottom: 6px;">Normalization:</h4>
                            <div class="toggle-container">
                                <label class="toggle-label">
                                    <input type="checkbox" id="use-local-normalization" checked>
                                    Renormalize scores for filtered data
                                </label>
                            </div>
                            <div id="local-norm-info" style="font-size: 11px; color: #888; margin-top: 4px; display: none;">
                                <div id="local-norm-status"></div>
                            </div>
                        </div>
                    </div>
                </div>
            
            <div style="margin-bottom: 15px;">
                <h3 style="font-size: 12px; color: #aaa; margin-bottom: 8px;">Exclude parcels without:</h3>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" id="filter-wui-zero-enabled">
                        WUI Coverage
                    </label>
                </div>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" id="filter-vhsz-zero-enabled">
                        Fire Hazards Coverage
                    </label>
                </div>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" id="filter-brns-enabled">
                        Burn Scars
                    </label>
                </div>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" id="filter-agri-protection-enabled">
                        Agricultural Protection
                    </label>
                </div>


            </div>

            <div>
                <h3 style="font-size: 12px; color: #aaa; margin-bottom: 8px;">Filter Parcels out based on:</h3>
                <div class="input-group" style="display: flex; align-items: center; margin-bottom: 8px; font-size: 12px;">
                    <input type="checkbox" id="filter-yearbuilt-enabled" style="margin-right: 8px; vertical-align: middle;">
                    <span style="white-space: nowrap; vertical-align: middle;">Built after year:</span>
                    <input type="number" class="number-input" id="filter-yearbuilt" min="1800" max="2024" value="1996" style="margin-left: 8px; width: 80px; vertical-align: middle;">
                </div>
                <div class="toggle-container" style="margin-left: 20px; margin-bottom: 8px;">
                    <label class="toggle-label">
                        <input type="checkbox" id="filter-yearbuilt-exclude-unknown">
                        Exclude Unknown Year Built
                    </label>
                </div>
                <div class="input-group" style="display: flex; align-items: center; margin-bottom: 8px; font-size: 12px;">
                    <input type="checkbox" id="filter-strcnt-enabled" style="margin-right: 8px; vertical-align: middle;">
                    <span style="white-space: nowrap; vertical-align: middle;">Minimum Number of Structures</span>
                    <input type="number" class="number-input" id="filter-strcnt" value="1" min="0" style="margin-left: 8px; width: 80px; vertical-align: middle;">
                </div>
                <div class="input-group" style="display: flex; align-items: center; margin-bottom: 8px; font-size: 12px;">
                    <input type="checkbox" id="filter-neigh1d-enabled" style="margin-right: 8px; vertical-align: middle;">
                    <span style="white-space: nowrap; vertical-align: middle;">Nearest neighboring structure distance</span>
                    <input type="number" class="number-input" id="filter-neigh1d" min="0" max="1000" value="50" style="margin-left: 8px; width: 80px; vertical-align: middle;">
                </div>
            </div>
            </div>
        </div>
        
        <div class="control-section">
            <div style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;" id="map-layers-header">
                <h2 style="margin: 0;">Map Layers</h2>
                <span style="margin-left: 8px; font-size: 12px; color: #888;" id="map-layers-toggle">▶</span>
            </div>
            <div id="map-layers-content" style="display: none; margin-left: 12px; padding-left: 8px; border-left: 2px solid rgba(255,255,255,0.1);">
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" class="layer-toggle" data-layer="parcels" checked>
                        Parcels
                    </label>
                </div>
                <div class="toggle-container" style="margin-left: 20px; margin-bottom: 10px;">
                    <label class="toggle-label" style="font-size: 12px; color: #ccc;">
                        Opacity:
                        <input type="range" id="parcels-opacity" min="0" max="100" value="80" style="width: 100px; margin-left: 8px;">
                    </label>
                </div>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" class="layer-toggle" data-layer="agricultural">
                        Agriculture
                    </label>
                </div>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" class="layer-toggle" data-layer="fuelbreaks">
                        Fuel Breaks
                    </label>
                </div>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" class="layer-toggle" data-layer="wui">
                        WUI Zone
                    </label>
                </div>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" class="layer-toggle" data-layer="hazard">
                        Very High Hazard Zone
                    </label> 
                </div>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" class="layer-toggle" data-layer="structures">
                        Structures
                    </label>
                </div>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" class="layer-toggle" data-layer="firewise">
                        Firewise Communities
                    </label>
                </div>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" class="layer-toggle" data-layer="burnscars">
                        Burn Scars
                    </label>
                </div>
                <h3 style="font-size: 12px; color: #aaa; margin: 15px 0 5px 0;">Base Layers</h3>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" class="layer-toggle" data-layer="dark" checked>
                        Dark
                    </label>
                </div>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" class="layer-toggle" data-layer="light">
                        Light
                    </label>
                </div> 
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" class="layer-toggle" data-layer="satellite">
                        Satellite
                    </label>
                </div>
            </div>
        </div>
        


        <div class="control-section">
            <h2>Weight Inference</h2>
            <p style="font-size: 11px; color: #aaa; margin-bottom: 10px;">Draw multiple areas to optimize weights for combined selection</p>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                <button class="button" id="draw-rectangle">Add Rectangle</button>
                <button class="button" id="draw-lasso">Add Lasso</button>
            </div>
            <div style="margin: 8px 0; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 3px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                    <span style="font-size: 11px; color: #aaa;">Selection Areas:</span>
                    <span style="font-size: 11px; color: #fff;" id="selection-count">0</span>
                </div>
                <div style="display: flex; gap: 5px;">
                    <button class="button small" id="clear-last-selection" disabled>Remove Last</button>
                    <button class="button small" id="clear-all-selections" disabled>Clear All</button>
                </div>
            </div>
            <button class="button" id="infer-weights" disabled>Infer Weights from Multi-Selection</button>
                                        <button class="button" id="download-lp-btn" disabled>Download .LP File</button>
                            <button class="button" id="download-txt-btn" disabled>Download .TXT Report</button>
                            <button class="button" id="view-solution-btn" disabled>View Solution Report</button>
            <p style="font-size: 10px; color: #888; margin: 5px 0;">↑ Maximizes total risk score across all selected areas</p>
            

        </div>
        

        

        </div> <!-- Close panel-content -->
    </div> <!-- Close control-panel -->
    
    <!-- Add measure tool container -->
    <div id="measure-container" class="measure-container">
        <div id="distance" class="distance-container"></div>
    </div>

    <div class="legend">
        <div class="legend-title">Fire Risk</div>
        <div class="legend-gradient"></div>
        <div class="legend-labels">
            <span>0.00</span>
            <span>1.00</span>
        </div>
        <div class="legend-item" style="margin-top: 10px;">
            <div class="legend-box"></div>
            <span>Selected for Treatment</span>
        </div>
    </div>

    <!-- Add modal for distribution plots -->
    <div id="dist-modal" class="modal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <div id="dist-plot"></div>
        </div>
    </div>

    <!-- Solution Report Modal -->
    <div id="solution-modal" class="modal">
        <div class="modal-content" style="max-width: 95%; width: 1200px; max-height: 90vh;">
            <span class="close-modal" id="close-solution-modal">&times;</span>
            <h2 style="margin: 0 0 15px 0; color: #fff; font-size: 18px;">Infer Weights Solution</h2>
            <pre id="solution-text" style="
                white-space: pre-wrap; 
                font-family: 'Courier New', monospace; 
                font-size: 11px; 
                line-height: 1.4; 
                max-height: 70vh; 
                overflow-y: auto; 
                background: #2a2a2a; 
                padding: 15px; 
                border-radius: 4px; 
                color: #e0e0e0;
                margin: 0;
                border: 1px solid rgba(255,255,255,0.2);
            "></pre>
        </div>
    </div>

    <!-- Correlation Matrix Modal -->
    <div id="correlation-modal" class="modal">
        <div class="modal-content" style="max-width: 95%; width: 800px; max-height: 90vh;">
            <span class="close-modal" id="close-correlation-modal">&times;</span>
            <div id="correlation-plot"></div>
        </div>
    </div>

    <script>
        // Custom rectangle drawing mode
        const DrawRectangle = {
            onSetup(opts) {
                const rectangle = this.newFeature({
                    type: 'Feature',
                    properties: {},
                    geometry: {
                        type: 'Polygon',
                        coordinates: [[]]
                    }
                });
                this.addFeature(rectangle);
                this.clearSelectedFeatures();
                this.map.doubleClickZoom.disable();
                this.updateUIClasses({ mouse: 'add' });
                this.setActionableState({ trash: true });
                return { rectangle, startPoint: null };
            },
            onClick(state, e) {
                if (!state.startPoint) {
                    state.startPoint = [e.lngLat.lng, e.lngLat.lat];
                } else {
                    const endPoint = [e.lngLat.lng, e.lngLat.lat];
                    if (endPoint[0] !== state.startPoint[0] || endPoint[1] !== state.startPoint[1]) {
                        this.updateUIClasses({ mouse: 'pointer' });
                        state.rectangle.updateCoordinate('0.4', ...state.startPoint);
                        this.changeMode('simple_select', { featuresId: [state.rectangle.id] });
                    }
                }
            },
            onMouseMove(state, e) {
                if (state.startPoint) {
                    const start = state.startPoint;
                    const current = [e.lngLat.lng, e.lngLat.lat];
                    state.rectangle.updateCoordinate('0.0', start[0], start[1]);
                    state.rectangle.updateCoordinate('0.1', current[0], start[1]);
                    state.rectangle.updateCoordinate('0.2', current[0], current[1]);
                    state.rectangle.updateCoordinate('0.3', start[0], current[1]);
                    state.rectangle.updateCoordinate('0.4', start[0], start[1]);
                }
            },
            onStop(state) {
                this.map.doubleClickZoom.enable();
                this.updateUIClasses({ mouse: 'none' });
                this.activateUIButton();
                if (!state.rectangle.getCoordinate('0.0')) return;
                if (state.rectangle.isValid()) {
                    state.rectangle.removeCoordinate('0.4');
                    this.map.fire('draw.create', { features: [state.rectangle.toGeoJSON()] });
                } else {
                    this.deleteFeature([state.rectangle.id], { silent: true });
                }
            },
            toDisplayFeatures(state, geojson, display) {
                const isActive = geojson.properties.id === state.rectangle.id;
                geojson.properties.active = isActive ? 'true' : 'false';
                if (!isActive) return display(geojson);
                if (!state.startPoint) return;
                return display(geojson);
            },
            onTrash(state) {
                this.deleteFeature([state.rectangle.id], { silent: true });
                this.changeMode('simple_select');
            }
        };

        // Custom lasso drawing mode with fixed keyboard handling
        const DrawLasso = {
            onSetup(opts) {
                const lasso = this.newFeature({
                    type: 'Feature',
                    properties: {},
                    geometry: {
                        type: 'Polygon',
                        coordinates: [[]]
                    }
                });
                this.addFeature(lasso);
                this.clearSelectedFeatures();
                this.map.doubleClickZoom.disable();
                this.updateUIClasses({ mouse: 'crosshair' });
                this.setActionableState({ trash: true });

                const state = { 
                    lasso, 
                    points: [], 
                    startPoint: null,
                    mode: 'draw_lasso'
                };

                const keydownHandler = (e) => {
                    if (e.key === 'Escape' || e.key === 'Enter') {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        if (state.points && state.points.length >= 3) {
                            // Close the lasso by connecting back to first point
                            const coordinates = [...state.points];
                            if (coordinates[0] !== coordinates[coordinates.length - 1]) {
                                coordinates.push(coordinates[0]);
                            }
                            
                            // Update the feature with closed coordinates
                            for (let i = 0; i < coordinates.length; i++) {
                                state.lasso.updateCoordinate(`0.${i}`, ...coordinates[i]);
                            }
                            
                            if (state.lasso.isValid()) {
                                this.map.fire('draw.create', { features: [state.lasso.toGeoJSON()] });
                            }
                        } else {
                            // Not enough points, just delete the feature
                            this.deleteFeature([state.lasso.id], { silent: true });
                        }
                        
                        // Clean up and exit drawing mode
                        document.removeEventListener('keydown', keydownHandler);
                        this.changeMode('simple_select');
                    }
                };

                document.addEventListener('keydown', keydownHandler);
                state.keydownHandler = keydownHandler;

                return state;
            },
            onClick(state, e) {
                const point = [e.lngLat.lng, e.lngLat.lat];
                
                if (!state.startPoint) {
                    state.startPoint = point;
                    state.points.push(point);
                } else {
                    const startPixel = this.map.project(state.startPoint);
                    const currentPixel = this.map.project(point);
                    const distance = Math.sqrt(
                        Math.pow(startPixel.x - currentPixel.x, 2) + 
                        Math.pow(startPixel.y - currentPixel.y, 2)
                    );
                    
                    if (distance < 10 && state.points.length >= 3) {
                        state.points.push(state.startPoint);
                        this.updateLasso(state);
                        
                        if (state.lasso.isValid()) {
                            this.map.fire('draw.create', { features: [state.lasso.toGeoJSON()] });
                        }
                        this.changeMode('simple_select');
                    } else {
                        state.points.push(point);
                        this.updateLasso(state);
                    }
                }
            },
            onMouseMove(state, e) {
                if (state.points.length > 0) {
                    const currentPoints = [...state.points, [e.lngLat.lng, e.lngLat.lat]];
                    this.updateLasso(state, currentPoints);
                }
            },
            updateLasso(state, points = state.points) {
                if (points.length < 3) return;
                
                const coordinates = [...points];
                if (coordinates[0] !== coordinates[coordinates.length - 1]) {
                    coordinates.push(coordinates[0]);
                }
                
                for (let i = 0; i < coordinates.length; i++) {
                    state.lasso.updateCoordinate(`0.${i}`, ...coordinates[i]);
                }
            },
            onStop(state) {
                this.map.doubleClickZoom.enable();
                this.updateUIClasses({ mouse: 'none' });
                this.activateUIButton();
                
                if (state.keydownHandler) {
                    document.removeEventListener('keydown', state.keydownHandler);
                }
                
                if (state.points.length < 3) {
                    this.deleteFeature([state.lasso.id], { silent: true });
                    return;
                }
                
                const coordinates = [...state.points];
                coordinates.push(coordinates[0]);
                
                for (let i = 0; i < coordinates.length; i++) {
                    state.lasso.updateCoordinate(`0.${i}`, ...coordinates[i]);
                }
                
                if (state.lasso.isValid()) {
                    this.map.fire('draw.create', { features: [state.lasso.toGeoJSON()] });
                } else {
                    this.deleteFeature([state.lasso.id], { silent: true });
                }
            },
            toDisplayFeatures(state, geojson, display) {
                const isActive = geojson.properties.id === state.lasso.id;
                geojson.properties.active = isActive ? 'true' : 'false';
                if (!isActive) return display(geojson);
                if (state.points.length < 2) return;
                return display(geojson);
            },
            onTrash(state) {
                if (state.keydownHandler) {
                    document.removeEventListener('keydown', state.keydownHandler);
                }
                this.deleteFeature([state.lasso.id], { silent: true });
                this.changeMode('simple_select');
            }
        };

        // Helper functions
        async function loadLayer(name) {
            try {
                const response = await fetch(`/api/${name}`);
                const geojson = await response.json();
                if (map.getSource(name)) {
                    map.getSource(name).setData(geojson);
                }
            } catch (error) {
                console.error(`Error loading ${name} layer:`, error);
            }
        }

        function updateSliderFill(slider) {
            const value = slider.value;
            const max = slider.max;
            const percentage = (value / max) * 100;
            slider.style.background = `linear-gradient(to right, #4a90e2 0%, #4a90e2 ${percentage}%, rgba(255, 255, 255, 0.2) ${percentage}%, rgba(255, 255, 255, 0.2) 100%)`;
        }

        function normalizeWeights() {
            const total = Array.from(weightSliders).reduce((sum, slider) => {
                const isEnabled = document.getElementById(`enable-${slider.id}`).checked;
                return sum + (isEnabled ? parseFloat(slider.value) : 0);
            }, 0);
            
            weightSliders.forEach(slider => {
                const isEnabled = document.getElementById(`enable-${slider.id}`).checked;
                const normalized = total > 0 && isEnabled ? (parseFloat(slider.value) / total * 100).toFixed(0) : 0;
                document.getElementById(slider.id + '-value').textContent = normalized + '%';
            });
        }

        function updateMaxParcels() {
                    const maxParcels = parseInt(document.getElementById('max-parcels').value) || 500;
            document.getElementById('max-parcels').value = maxParcels;
            document.getElementById('max-parcels-value').textContent = maxParcels;
        }

        // Helper function to update distribution buttons based on score type
        function updateDistributionButtons() {
            const useQuantile = document.getElementById('use-quantile').checked;
            const suffix = useQuantile ? '_z' : '_s';
            
            // Update all score distribution buttons
            document.querySelectorAll('.dist-button').forEach(button => {
                const onclick = button.getAttribute('onclick');
                if (onclick && onclick.includes("Score</button>")) {
                    // Extract base variable name from onclick attribute
                    const match = onclick.match(/showDistribution\('(.+)_[sz]'\)/);
                    if (match) {
                        const baseVar = match[1];
                        button.setAttribute('onclick', `window.plottingManager.showDistribution('${baseVar}${suffix}')`);
                    }
                }
            });
            
            console.log(`Updated distribution buttons to use ${suffix} suffix for score plots`);
        }

        function getCurrentFilters() {
            return {
                yearbuilt_max: document.getElementById('filter-yearbuilt-enabled').checked ? 
                    parseInt(document.getElementById('filter-yearbuilt').value) : null,
                exclude_yearbuilt_unknown: document.getElementById('filter-yearbuilt-exclude-unknown').checked,
                neigh1d_max: document.getElementById('filter-neigh1d-enabled').checked ? 
                    parseInt(document.getElementById('filter-neigh1d').value) : null,
                strcnt_min: document.getElementById('filter-strcnt-enabled').checked ? 
                    parseInt(document.getElementById('filter-strcnt').value) : null,
                exclude_wui_zero: document.getElementById('filter-wui-zero-enabled').checked,
                exclude_vhsz_zero: document.getElementById('filter-vhsz-zero-enabled').checked,
                exclude_no_brns: document.getElementById('filter-brns-enabled').checked,
                exclude_agri_protection: document.getElementById('filter-agri-protection-enabled').checked,
                use_quantile: document.getElementById('use-quantile').checked,
                use_local_normalization: document.getElementById('use-local-normalization').checked,
                subset_area: subsetArea
            };
        }

        function getActiveScoreVariable(baseVar) {
            const useQuantile = document.getElementById('use-quantile').checked;
            
            if (useQuantile) {
                return baseVar + '_z';
            } else {
                return baseVar + '_s';
            }
        }

        function createPopupContent(props) {
            const useQuantile = document.getElementById('use-quantile').checked;
            let suffix, scoreType;
            
            if (useQuantile) {
                suffix = '_z';
                scoreType = 'Quantile';
            } else {
                suffix = '_s';
                scoreType = 'Basic Min-Max';
            }
            
            return `
                <div style="max-height: 300px; overflow-y: auto; padding-right: 10px;">
                    <h3>${props.apn || 'Parcel Information'}</h3>
                    
                    <div style="margin: 10px 0; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 4px;">
                        <p style="margin: 0;"><strong>Total Score:</strong> ${props.score?.toFixed(3) || 'N/A'}</p>
                        <p style="margin: 5px 0 0 0;"><strong>Rank:</strong> ${props.rank || 'N/A'}</p>
                    </div>

                    <div style="margin: 10px 0;">
                        <h4 style="margin: 0 0 5px 0; font-size: 12px; color: #aaa;">Raw Values</h4>
                        <p><strong>Nearest Neighbor:</strong> ${props.neigh1_d?.toFixed(2) || 'N/A'} ft</p>
                        <p><strong>Year Built:</strong> ${props.yearbuilt || 'Unknown'}</p>
                        <p><strong>Number of Burn Scars:</strong> ${props.num_brns || 'N/A'}</p>
                        <p><strong>Structures in 1/4 mi:</strong> ${props.qtrmi_cnt || 'N/A'}</p>
                        <p><strong>Structure Count:</strong> ${props.strcnt || 'N/A'}</p>
                        <p><strong>WUI % (1/2 mi):</strong> ${props.hlfmi_wui?.toFixed(2) || 'N/A'}%</p>
                        <p><strong>Fire VHSZ % (1/2 mi):</strong> ${props.hlfmi_vhsz?.toFixed(2) || 'N/A'}%</p>
                        <p><strong>Agricultural % (1/2 mi):</strong> ${props.hlfmi_agri?.toFixed(2) || 'N/A'}%</p>
                        <p><strong>Firebreak % (1/2 mi):</strong> ${props.hlfmi_fb?.toFixed(2) || 'N/A'}%</p>
                        <p><strong>Burn Scar % (1/2 mi):</strong> ${props.hlfmi_brn?.toFixed(2) || 'N/A'}%</p>
                        <p><strong>Slope within 100 ft:</strong> ${props.par_buf_sl?.toFixed(2) || 'N/A'}°</p>
                        <p><strong>Agriculture & Fuelbreaks (1/2 mi):</strong> ${props.hlfmi_agfb?.toFixed(2) || 'N/A'}%</p>
                        <p><strong>Number of Neighbors:</strong> ${props.num_neighb || 'N/A'}</p>
                        <p><strong>Parcel Slope:</strong> ${props.avg_slope?.toFixed(2) || 'N/A'}°</p>
                        <p><strong>Max Slope:</strong> ${props.max_slope?.toFixed(2) || 'N/A'}°</p>
                        <p><strong>Elevation:</strong> ${props.par_elev?.toFixed(2) || 'N/A'} ft</p>
                        <p><strong>Aspect:</strong> ${props.par_asp_dr || 'N/A'}</p>
                    </div>

                    <div style="margin: 10px 0;">
                        <h4 style="margin: 0 0 5px 0; font-size: 12px; color: #aaa;">Risk Factor Scores (${scoreType})</h4>
                        <p><strong>Structures (1/4 mi):</strong> ${props['qtrmi' + suffix]?.toFixed(3) || 'N/A'}</p>
                        <p><strong>WUI Coverage (1/2 mi):</strong> ${props['hwui' + suffix]?.toFixed(3) || 'N/A'}</p>
                        <p><strong>Agriculture Coverage (1/2 mi):</strong> ${props['hagri' + suffix]?.toFixed(3) || 'N/A'}</p>
                        <p><strong>Fire Hazard Coverage (1/2 mi):</strong> ${props['hvhsz' + suffix]?.toFixed(3) || 'N/A'}</p>
                        <p><strong>Firebreak Coverage (1/2 mi):</strong> ${props['hfb' + suffix]?.toFixed(3) || 'N/A'}</p>
                        <p><strong>Slope Score:</strong> ${props['slope' + suffix]?.toFixed(3) || 'N/A'}</p>
                        <p><strong>Neighbor Distance Score:</strong> ${props['neigh1d' + suffix]?.toFixed(3) || 'N/A'}</p>
                        <p><strong>Burn Scar Coverage (1/2 mi):</strong> ${props['hbrn' + suffix]?.toFixed(3) || 'N/A'}</p>
                        <p><strong>Slope within 100 ft Score:</strong> ${props['par_buf_sl' + suffix]?.toFixed(3) || 'N/A'}</p>
                        <p><strong>Agriculture & Fuelbreaks Score:</strong> ${props['hlfmi_agfb' + suffix]?.toFixed(3) || 'N/A'}</p>
                    </div>
                </div>
            `;
        }

        function createBurnscarPopupContent(props) {
            return `
                <div style="color: #ffffff; font-family: Arial, sans-serif; max-width: 300px;">
                    <h3 style="margin: 0 0 10px 0; color: #cc7722; border-bottom: 2px solid #cc7722; padding-bottom: 5px;">
                        ${props.incidentna || 'Unknown Fire'} Fire
                    </h3>
                    <div style="margin: 10px 0;">
                        <p><strong>Fire Year:</strong> ${props.fireyear ? Math.round(props.fireyear) : 'Unknown'}</p>
                        <p><strong>Acres Burned:</strong> ${props.gisacres ? props.gisacres.toLocaleString() + ' acres' : 'Unknown'}</p>
                        <p><strong>Fire ID:</strong> ${props.id || 'N/A'}</p>
                    </div>
                </div>
            `;
        }

        // Initialize map
        mapboxgl.accessToken = '{{ mapbox_token }}' || 'YOUR_MAPBOX_TOKEN';
        
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/dark-v11',
            center: [-119.758714, 34.44195],
            zoom: 11,
            pitch: 0,
            bearing: 0
        });

        // Initialize drawing
        const draw = new MapboxDraw({
            displayControlsDefault: false,
            modes: {
                ...MapboxDraw.modes,
                draw_rectangle: DrawRectangle,
                draw_lasso: DrawLasso
            },
            controls: {
                polygon: false,
                trash: false
            },
            styles: [
                {
                    'id': 'gl-draw-polygon-fill-inactive',
                    'type': 'fill',
                    'filter': ['all', ['==', 'active', 'false'], ['==', '$type', 'Polygon']],
                    'paint': {
                        'fill-color': '#ffcc00',
                        'fill-outline-color': '#ffcc00',
                        'fill-opacity': 0.3
                    }
                },
                {
                    'id': 'gl-draw-polygon-stroke-inactive',
                    'type': 'line',
                    'filter': ['all', ['==', 'active', 'false'], ['==', '$type', 'Polygon']],
                    'paint': {
                        'line-color': '#ffcc00',
                        'line-width': 2
                    }
                },
                {
                    'id': 'gl-draw-polygon-fill-active',
                    'type': 'fill',
                    'filter': ['all', ['==', 'active', 'true'], ['==', '$type', 'Polygon']],
                    'paint': {
                        'fill-color': '#ffcc00',
                        'fill-outline-color': '#ffcc00',
                        'fill-opacity': 0.3
                    }
                },
                {
                    'id': 'gl-draw-polygon-stroke-active',
                    'type': 'line',
                    'filter': ['all', ['==', 'active', 'true'], ['==', '$type', 'Polygon']],
                    'paint': {
                        'line-color': '#ffcc00',
                        'line-width': 2
                    }
                }
            ]
        });
        map.addControl(draw, 'top-right');

        // State variables
        let currentData = null;
        let currentSessionId = null;
        let selectedParcels = [];
        let measureMode = false;
        let measurePoints = [];
        let measureLine = null;
        let subsetArea = null;
        
        // Multi-area selection for weight inference
        let selectionAreas = [];
        let isAddingSelection = false;
        
        // Variables for optimization session (memory optimized)
        let currentOptimizationSession = null;

        // Get DOM elements
        const weightSliders = document.querySelectorAll('.weight-slider');
        const modal = document.getElementById('dist-modal');
        const closeModal = document.getElementsByClassName('close-modal')[0];
        const measureButton = document.createElement('button');
        measureButton.className = 'button';
        measureButton.textContent = 'Measure Distance';
        measureButton.style.marginBottom = '10px';
        document.getElementById('measure-container').insertBefore(measureButton, document.getElementById('distance'));

        // Raw variable mapping for distribution plots
        const rawVarMap = {
            'qtrmi': 'qtrmi_cnt',
            'hwui': 'hlfmi_wui',
            'hagri': 'hlfmi_agri',
            'hvhsz': 'hlfmi_vhsz',
            'hfb': 'hlfmi_fb',
            'slope': 'slope_s',
            'neigh1d': 'neigh1_d',
            'hbrn': 'hlfmi_brn',
            'par_buf_sl': 'par_buf_sl',
            'hlfmi_agfb': 'hlfmi_agfb'
        };

        // Variable name mapping for readable titles
        const varNameMap = {
            'qtrmi_cnt': 'Quarter Mile Count',
            'hlfmi_wui': 'WUI Score',
            'hlfmi_agri': 'Agriculture Score',
            'hlfmi_vhsz': 'Very High Fire Hazard',
            'hlfmi_fb': 'Fuel Break Score',
            'slope_s': 'Slope Score',
            'neigh1_d': 'Neighbor Distance',
            'hlfmi_brn': 'Burn Score',
            'qtrmi_s': 'Quarter Mile Score',
            'qtrmi_z': 'Quarter Mile Score (Quantile)',
            'hwui_s': 'WUI Score',
            'hwui_z': 'WUI Score (Quantile)',
            'hagri_s': 'Agriculture Score',
            'hagri_z': 'Agriculture Score (Quantile)',
            'hvhsz_s': 'Very High Fire Hazard Score',
            'hvhsz_z': 'Very High Fire Hazard Score (Quantile)',
            'hfb_s': 'Fuel Break Score',
            'hfb_z': 'Fuel Break Score (Quantile)',
            'slope_s': 'Slope Score',
            'slope_z': 'Slope Score (Quantile)',
            'neigh1d_s': 'Neighbor Distance Score',
            'neigh1d_z': 'Neighbor Distance Score (Quantile)',
            'hbrn_s': 'Burn Score',
            'hbrn_z': 'Burn Score (Quantile)',
            'par_buf_sl': 'Slope within 100 ft',
            'par_buf_sl_s': 'Slope within 100 ft Score',
            'par_buf_sl_z': 'Slope within 100 ft Score (Quantile)',
            'hlfmi_agfb': 'Agriculture & Fuelbreaks',
            'hlfmi_agfb_s': 'Agriculture & Fuelbreaks Score',
            'hlfmi_agfb_z': 'Agriculture & Fuelbreaks Score (Quantile)'
        };

        // Enhanced update scores function with comprehensive client-side processing
        async function updateScores(isFilterChange = false) {
            const overallStartTime = performance.now();
            console.log(`=== ${isFilterChange ? 'FULL LOAD' : 'CLIENT PROCESSING'} STARTED ===`);
            
            document.getElementById('spinner').style.display = 'block';
            
            // Get current weights
            const weights = {};
            const total = Array.from(weightSliders).reduce((sum, slider) => {
                const isEnabled = document.getElementById(`enable-${slider.id}`).checked;
                return sum + (isEnabled ? parseFloat(slider.value) : 0);
            }, 0);
            
            weightSliders.forEach(slider => {
                const isEnabled = document.getElementById(`enable-${slider.id}`).checked;
                weights[slider.id] = total > 0 && isEnabled ? parseFloat(slider.value) / total : 0;
            });
            
            const maxParcels = parseInt(document.getElementById('max-parcels').value);
            const filters = getCurrentFilters();
            
            try {
                // Check if we have complete dataset stored and can use client-side processing
                if (window.fireRiskScoring.getCompleteDatasetCount() > 0) {
                    console.log('Using comprehensive client-side processing (filtering + scoring)');
                    
                    // Use the new processData method for everything client-side
                    const clientResult = window.fireRiskScoring.processData(
                        weights, 
                        filters, 
                        maxParcels,
                        filters.use_local_normalization,
                        filters.use_quantile
                    );
                    
                    if (clientResult) {
                        // Update current data
                        currentData = clientResult;
                        updateMap();
                        updateStatistics();
                        
                        // Update normalization display with client-side stats
                        updateNormalizationDisplay(filters);
                        
                        // Auto-refresh score distribution plot if the modal is open
                        if (modal.style.display === 'block') {
                            refreshScoreDistributionPlot();
                        }
                        
                        const totalTime = performance.now() - overallStartTime;
                        console.log(`=== CLIENT PROCESSING COMPLETED in ${totalTime.toFixed(1)}ms ===`);
                        return;
                    }
                }
                
                // First time load: fetch complete dataset from server
                console.log('Loading complete dataset from server (first time)');
                
                const responseData = await window.apiClient.prepareData({
                    weights,
                    use_quantile: filters.use_quantile,
                    use_local_normalization: filters.use_local_normalization,
                    max_parcels: maxParcels,
                    subset_area: filters.subset_area,
                    ...filters
                });
                
                // Store complete dataset for future client-side processing
                const storedCount = window.fireRiskScoring.storeCompleteData(responseData);
                console.log(`✓ Stored ${storedCount} parcels for client-side processing`);
                
                // ALWAYS use client-side score calculation, even on first load
                console.log('🔄 FIRST CLIENT-SIDE CALCULATION STARTING...');
                console.log(`   - Weights:`, weights);
                console.log(`   - Max parcels: ${maxParcels}`);
                console.log(`   - Local normalization: ${filters.use_local_normalization}`);
                console.log(`   - Use quantile: ${filters.use_quantile}`);

                
                const firstCalcStart = performance.now();
                const clientResult = window.fireRiskScoring.processData(
                    weights, 
                    filters, 
                    maxParcels,
                    filters.use_local_normalization,
                    filters.use_quantile
                );
                const firstCalcTime = performance.now() - firstCalcStart;
                
                // Use client-calculated scores, not server precomputed scores
                if (clientResult) {
                    currentData = clientResult;
                    console.log(`✅ FIRST CLIENT-SIDE CALCULATION SUCCEEDED in ${firstCalcTime.toFixed(1)}ms`);
                    console.log(`   - Calculated scores for ${clientResult.features.length} parcels`);
                    console.log(`   - Top ${clientResult.selected_count} parcels selected`);
                    console.log(`   - Using client-calculated composite scores (not precomputed)`);
                } else {
                    console.error(`❌ FIRST CLIENT-SIDE CALCULATION FAILED after ${firstCalcTime.toFixed(1)}ms`);
                    console.error('   - Falling back to server precomputed scores');
                    currentData = responseData;
                }
                updateMap();
                updateStatistics();
                
                // Update normalization mode display using client-calculated data
                updateNormalizationDisplay(filters);
                
                // Auto-refresh score distribution plot if the modal is open
                if (modal.style.display === 'block') {
                    refreshScoreDistributionPlot();
                }
                
                const totalTime = performance.now() - overallStartTime;
                console.log(`=== INITIAL LOAD COMPLETED in ${totalTime.toFixed(1)}ms ===`);
                
            } catch (error) {
                console.error('Error updating scores:', error);
                alert('Error loading data. Please try again.');
            } finally {
                document.getElementById('spinner').style.display = 'none';
            }
        }

        // Helper function to update normalization display with client-side data
        function updateNormalizationDisplay(filters) {
            const filterStats = window.clientFilterManager.getFilterStats();
            if (filterStats) {
                document.getElementById('normalization-row').style.display = 'flex';
                if (filters.use_local_normalization) {
                    document.getElementById('normalization-mode').textContent = 
                        `Local (${filterStats.total_parcels_after_filter} parcels)`;
                    document.getElementById('local-norm-info').style.display = 'block';
                    document.getElementById('local-norm-status').textContent = 
                        `✓ Scores renormalized on ${filterStats.total_parcels_after_filter} filtered parcels`;
                } else {
                    document.getElementById('normalization-mode').textContent = 
                        `Global (${filterStats.total_parcels_after_filter} of ${filterStats.total_parcels_before_filter} parcels)`;
                    document.getElementById('local-norm-info').style.display = 'none';
                }
            }
        }

        // Multi-area selection management
        function updateSelectionCount() {
            document.getElementById('selection-count').textContent = selectionAreas.length;
            
            // Update button states
            const hasSelections = selectionAreas.length > 0;
            document.getElementById('clear-last-selection').disabled = !hasSelections;
            document.getElementById('clear-all-selections').disabled = !hasSelections;
            document.getElementById('infer-weights').disabled = !hasSelections;
            
            // Clear optimization session when selections change
            if (hasSelections) {
                currentOptimizationSession = null;
                document.getElementById('download-lp-btn').disabled = true;
                document.getElementById('download-txt-btn').disabled = true;
                document.getElementById('view-solution-btn').disabled = true;
            }
        }

        function addSelectionArea(geometry, type, featureId = null) {
            const selectionId = featureId || `selection_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            selectionAreas.push({
                id: selectionId,
                featureId: featureId,
                geometry: geometry,
                type: type,
                timestamp: Date.now()
            });
            
            updateSelectionCount();
            console.log(`Added ${type} selection area. Total areas: ${selectionAreas.length}`);
        }

        function removeLastSelectionArea() {
            if (selectionAreas.length > 0) {
                const removed = selectionAreas.pop();
                
                // Remove the corresponding drawn feature if it has a featureId
                if (removed.featureId) {
                    const allFeatures = draw.getAll();
                    const featureToDelete = allFeatures.features.find(f => f.id === removed.featureId);
                    if (featureToDelete) {
                        draw.delete(removed.featureId);
                    }
                }
                
                updateSelectionCount();
                console.log(`Removed last selection area (${removed.type}). Remaining: ${selectionAreas.length}`);
            }
        }

        function clearAllSelectionAreas() {
            // Clear all drawn features that are part of our selection areas
            selectionAreas.forEach(area => {
                if (area.featureId) {
                    try {
                        draw.delete(area.featureId);
                    } catch (e) {
                        // Feature might already be deleted, ignore
                    }
                }
            });
            
            // Also clear any remaining drawn features
            draw.deleteAll();
            
            selectionAreas = [];
            updateSelectionCount();
            console.log('Cleared all selection areas');
        }

        function combineSelectionAreas() {
            if (selectionAreas.length === 0) return null;
            
            if (selectionAreas.length === 1) {
                return selectionAreas[0].geometry;
            }
            
            // For multiple areas, create a union using Turf.js
            if (window.turf && window.turf.union && window.turf.feature) {
                try {
                    console.log(`Combining ${selectionAreas.length} selection areas using Turf.js`);
                    
                    let combined = window.turf.feature(selectionAreas[0].geometry);
                    
                    for (let i = 1; i < selectionAreas.length; i++) {
                        const nextFeature = window.turf.feature(selectionAreas[i].geometry);
                        combined = window.turf.union(combined, nextFeature);
                    }
                    
                    console.log(`Union result type: ${combined.geometry.type}`);
                    
                    // Return just the geometry, not the full feature
                    return combined.geometry;
                } catch (error) {
                    console.error('Failed to union selection areas:', error);
                    // Fall back to returning all areas as separate features for backend OR processing
                    console.log('Falling back to FeatureCollection approach');
                    return {
                        type: "FeatureCollection",
                        features: selectionAreas.map(area => ({
                            type: "Feature",
                            geometry: area.geometry
                        }))
                    };
                }
            } else {
                console.warn('Turf.js not fully available, using FeatureCollection fallback');
                // Return all areas as separate features for backend OR processing
                return {
                    type: "FeatureCollection",
                    features: selectionAreas.map(area => ({
                        type: "Feature",
                        geometry: area.geometry
                    }))
                };
            }
        }

        function updateStatistics() {
            if (!currentData || !currentData.features) return;
            
            const totalParcels = currentData.features.length;
            const selectedCount = currentData.features.filter(f => f.properties.top500).length;
            const totalRisk = currentData.features
                .filter(f => f.properties.top500)
                .reduce((sum, f) => sum + f.properties.score, 0);
            const avgRisk = selectedCount > 0 ? totalRisk / selectedCount : 0;
            
            document.getElementById('total-parcels').textContent = totalParcels.toLocaleString();
            document.getElementById('selected-parcels').textContent = selectedCount.toLocaleString();
            document.getElementById('total-risk').textContent = totalRisk.toFixed(2);
            document.getElementById('avg-risk').textContent = avgRisk.toFixed(2);
        }
        
        function updateMap() {
            if (!currentData) return;
            
            console.log('VECTOR TILES: Updating map styling with attribute data...');
            
            // Handle both old FeatureCollection and new AttributeCollection formats
            let attributes;
            if (currentData.type === "AttributeCollection") {
                attributes = currentData.attributes;
            } else if (currentData.type === "FeatureCollection") {
                // Legacy format - extract properties
                attributes = currentData.features.map(feature => feature.properties);
            } else {
                console.error('VECTOR TILES: Unknown data format:', currentData.type);
                return;
            }
            
            // Build score lookup for styling
            const scoreObject = {};
            const top500Ids = [];
            
            attributes.forEach(attr => {
                if (attr.parcel_id && attr.score !== undefined) {
                    scoreObject[attr.parcel_id.toString()] = attr.score;
                    if (attr.top500) {
                        top500Ids.push(attr.parcel_id.toString());
                    }
                }
            });
            
            // Update global variables for expressions
            window.parcelScores = scoreObject;
            window.top500ParcelIds = top500Ids;
            
            console.log(`VECTOR TILES: Updated styling data for ${Object.keys(scoreObject).length} parcels (${top500Ids.length} top parcels)`);
            
            // Update map paint properties with new scores
            map.setPaintProperty('parcels-fill', 'fill-color', [
                'case',
                ['has', ['to-string', ['get', 'parcel_id']], ['literal', scoreObject]],
                [
                    'interpolate',
                    ['linear'],
                    ['get', ['to-string', ['get', 'parcel_id']], ['literal', scoreObject]],
                    0, '#ffffff',
                    0.2, '#ffdddd', 
                    0.4, '#ffaaaa',
                    0.6, '#ff6666',
                    0.8, '#ff3333',
                    1, '#990000'
                ],
                '#eeeeee' // Default color for parcels without scores
            ]);
            
            // Update top 500 filter
            map.setFilter('parcels-top500', ['in', ['to-string', ['get', 'parcel_id']], ['literal', top500Ids]]);
            
            console.log('VECTOR TILES: Map styling updated successfully');
        }
        


        function exitMeasureMode() {
            measureMode = false;
            measureButton.textContent = 'Measure Distance';
            if (measureLine) {
                map.removeLayer('measure-line');
                map.removeSource('measure-line');
            }
            measurePoints = [];
            document.getElementById('distance').textContent = '';
        }
 


        // Event listeners
        document.getElementById('parcels-opacity').addEventListener('input', (e) => {
            const opacity = parseInt(e.target.value) / 100;
            if (map.getLayer('parcels-fill')) {
                map.setPaintProperty('parcels-fill', 'fill-opacity', opacity);
            }
        });

        weightSliders.forEach(slider => {
            updateSliderFill(slider);
            slider.addEventListener('input', () => {
                updateSliderFill(slider);
                normalizeWeights();
                // Don't auto-calculate on weight changes - wait for Calculate button
            });
        });

        // Calculate button - all processing is now client-side after initial load
        document.getElementById('calculate-btn').addEventListener('click', () => {
            updateScores(); // Always use client-side processing
        });
        document.getElementById('max-parcels').addEventListener('change', () => {
            updateMaxParcels();
            updateScores();
        });

        // Advanced Score Options expandable dropdown
        document.getElementById('advanced-score-header').addEventListener('click', () => {
            const content = document.getElementById('advanced-score-content');
            const toggle = document.getElementById('advanced-score-toggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        });

        // Results expandable dropdown
        document.getElementById('results-header').addEventListener('click', () => {
            const content = document.getElementById('results-content');
            const toggle = document.getElementById('results-toggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        });

        // Filters expandable dropdown
        document.getElementById('filters-header').addEventListener('click', () => {
            const content = document.getElementById('filters-content');
            const toggle = document.getElementById('filters-toggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        });

        // Map Layers expandable dropdown
        document.getElementById('map-layers-header').addEventListener('click', () => {
            const content = document.getElementById('map-layers-content');
            const toggle = document.getElementById('map-layers-toggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        });

        // Filter and normalization controls - all use client-side processing
        const filters = ['filter-yearbuilt-enabled', 'filter-neigh1d-enabled', 'filter-yearbuilt-exclude-unknown', 
                        'filter-strcnt-enabled', 'filter-wui-zero-enabled', 'filter-vhsz-zero-enabled', 
                        'filter-brns-enabled', 'filter-agri-protection-enabled', 'use-basic-scores', 'use-local-normalization'];
        filters.forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                updateScores(); // Client-side processing handles all changes
            });
        });

        // Special handling for score type changes to update distribution buttons
        document.getElementById('use-quantile').addEventListener('change', () => {
            updateDistributionButtons(); // Update button onclick attributes
            updateScores(); // Client-side processing handles all changes
        });

        ['filter-yearbuilt', 'filter-neigh1d', 'filter-strcnt'].forEach(id => {
            const element = document.getElementById(id);
            element.addEventListener('change', () => {
                updateScores();
            });
            element.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    updateScores();
                }
            });
        });



        // Download .LP file (memory optimized - on-demand from server)
        document.getElementById('download-lp-btn').addEventListener('click', async () => {
            if (!currentOptimizationSession) {
                alert('No optimization session available. Please run weight optimization first.');
                return;
            }
            
            try {
                console.log('Downloading LP file on-demand (memory optimized)');
                const response = await fetch(`/api/download-lp/${currentOptimizationSession}`);
                
                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }
                
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'fire_risk_optimization.lp';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                
                console.log('LP file downloaded successfully - no client storage used');
            } catch (error) {
                console.error('Error downloading LP file:', error);
                alert('Error downloading LP file. Please try again.');
            }
        });

        // Download .TXT report (memory optimized - on-demand from server)
        document.getElementById('download-txt-btn').addEventListener('click', async () => {
            if (!currentOptimizationSession) {
                alert('No optimization session available. Please run weight optimization first.');
                return;
            }
            
            try {
                console.log('Downloading TXT report on-demand (memory optimized)');
                const response = await fetch(`/api/download-txt/${currentOptimizationSession}`);
                
                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }
                
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'fire_risk_solution.txt';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                
                console.log('TXT report downloaded successfully - no client storage used');
            } catch (error) {
                console.error('Error downloading TXT report:', error);
                alert('Error downloading TXT report. Please try again.');
            }
        });

        // View solution report in modal (memory optimized - on-demand from server)
        document.getElementById('view-solution-btn').addEventListener('click', async () => {
            if (!currentOptimizationSession) {
                alert('No optimization session available. Please run weight optimization first.');
                return;
            }
            
            try {
                console.log('Loading solution on-demand (memory optimized)');
                const response = await fetch(`/api/view-solution/${currentOptimizationSession}`);
                
                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }
                
                const htmlContent = await response.text();
                const newWindow = window.open();
                newWindow.document.write(htmlContent);
                newWindow.document.title = 'Fire Risk Optimization Solution';
                
                console.log('Solution viewed successfully - no client storage used');
            } catch (error) {
                console.error('Error viewing solution:', error);
                alert('Error viewing solution. Please try again.');
            }
        });

        // Multi-area selection handlers - Add Rectangle
        document.getElementById('draw-rectangle').addEventListener('click', () => {
            isAddingSelection = true;
            draw.changeMode('draw_rectangle');
        });

        // Multi-area selection handlers - Add Lasso
        document.getElementById('draw-lasso').addEventListener('click', () => {
            isAddingSelection = true;
            draw.changeMode('draw_lasso');
        });

        // Multi-area selection handlers - Remove Last
        document.getElementById('clear-last-selection').addEventListener('click', () => {
            removeLastSelectionArea();
        });

        // Multi-area selection handlers - Clear All
        document.getElementById('clear-all-selections').addEventListener('click', () => {
            clearAllSelectionAreas();
        });
        
        // Subset selection event handlers
        document.getElementById('subset-rectangle').addEventListener('click', () => {
            draw.deleteAll();
            draw.changeMode('draw_rectangle');
            document.getElementById('subset-rectangle').dataset.mode = 'subset';
        });

        document.getElementById('subset-lasso').addEventListener('click', () => {
            draw.deleteAll();
            draw.changeMode('draw_lasso');
            document.getElementById('subset-lasso').dataset.mode = 'subset';
        });

        document.getElementById('clear-subset').addEventListener('click', () => {
            subsetArea = null;
            document.getElementById('subset-indicator').style.display = 'none';
            document.getElementById('filter-parcels').disabled = true;
            
            // Clear any drawn shapes
            draw.deleteAll();
            
            // Use client-side processing to remove spatial filter
            updateScores();
        });

        document.getElementById('filter-parcels').addEventListener('click', () => {
            const features = draw.getAll().features;
            if (features.length && subsetArea) {
                console.log('Applying spatial filter with subsetArea:', subsetArea);
                document.getElementById('subset-indicator').style.display = 'block';
                
                // Clear the drawn shape from the map after filtering
                draw.deleteAll();
                
                // Use client-side processing for spatial filtering
                updateScores();
            } else {
                console.log('No features or subsetArea to filter with. Features:', features.length, 'subsetArea:', subsetArea);
            }
        });
        
        // Multi-area infer weights handler
        document.getElementById('infer-weights').addEventListener('click', async () => {
            if (selectionAreas.length === 0) {
                alert('Please draw at least one selection area first!');
                return;
            }

            const combinedSelection = combineSelectionAreas();
            if (!combinedSelection) {
                alert('Error combining selection areas. Please try again.');
                return;
            }

            const maxParcels = parseInt(document.getElementById('max-parcels').value);

            const includeVars = Array.from(weightSliders)
                .map(slider => slider.id)
                .filter(varName => {
                    const cb = document.getElementById(`enable-${varName}`);
                    return cb && cb.checked;
                });

            document.getElementById('spinner').style.display = 'block';

            try {
                console.log(`Optimizing weights for ${selectionAreas.length} selection areas:`, 
                    selectionAreas.map(area => area.type));

                const data = await window.apiClient.inferWeights({
                    selection: combinedSelection,
                    selection_areas: selectionAreas, // Send all individual areas for reference
                    max_parcels: maxParcels,
                    include_vars: includeVars,

                    use_quantile: document.getElementById('use-quantile').checked,
                    ...getCurrentFilters()
                });

                // Store only the session ID (memory optimized - no bulk data)
                currentOptimizationSession = data.session_id;
                console.log(`Memory optimization: Stored only session ID, no bulk data in client`);

                // Clear any previous optimization data to prevent memory buildup
                selectedParcels = [];

                // Enable the download and view buttons if files are available
                document.getElementById('download-lp-btn').disabled = false;
                document.getElementById('download-txt-btn').disabled = false;
                document.getElementById('view-solution-btn').disabled = false;

                // Update the weight sliders with optimized values
                Object.entries(data.weights).forEach(([key, value]) => {
                    const slider = document.getElementById(key);
                    if (slider) {
                        slider.value = value;
                        updateSliderFill(slider);
                    }
                });

                normalizeWeights();
                await updateScores();
                
                // Clear the drawn features after successful optimization
                clearAllSelectionAreas();
                
            } catch (error) {
                console.error('Error inferring weights:', error);
                alert(error.message);
            } finally {
                document.getElementById('spinner').style.display = 'none';
            }
        });


        document.getElementById('export-shapefile').addEventListener('click', async () => {
            if (!currentData) return;
            
            const selectedFeatures = currentData.features.filter(f => f.properties.top500);
            const exportData = {
                type: 'FeatureCollection',
                features: selectedFeatures
            };
            
            try {
                const response = await fetch('/api/export-shapefile', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(exportData)
                });
                
                if (!response.ok) {
                    throw new Error('Export failed');
                }
                
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'fire_risk_selected_parcels.zip';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
            } catch (error) {
                console.error('Error exporting shapefile:', error);
                alert('Failed to export shapefile. Please try again.');
            }
        });

        document.getElementById('score-distribution-btn').addEventListener('click', () => {
            if (!currentData) {
                alert('Please calculate scores first');
                return;
            }

            const scores = currentData.features.map(f => f.properties.score);
            const selectedScores = currentData.features
                .filter(f => f.properties.top500)
                .map(f => f.properties.score);

            // Get selected area scores if available
            let selectedAreaScores = [];
            if (selectedParcels && selectedParcels.length > 0) {
                selectedAreaScores = selectedParcels.map(f => f.properties.score);
            }

            // Calculate statistics for all scores
            const allScoresMean = scores.reduce((a, b) => a + b, 0) / scores.length;
            const allScoresMin = Math.min(...scores);
            const allScoresMax = Math.max(...scores);
            const allScoresStd = Math.sqrt(scores.reduce((a, b) => a + Math.pow(b - allScoresMean, 2), 0) / scores.length);

            // Calculate statistics for selected scores
            const selectedScoresMean = selectedScores.reduce((a, b) => a + b, 0) / selectedScores.length;
            const selectedScoresMin = Math.min(...selectedScores);
            const selectedScoresMax = Math.max(...selectedScores);
            const selectedScoresStd = Math.sqrt(selectedScores.reduce((a, b) => a + Math.pow(b - selectedScoresMean, 2), 0) / selectedScores.length);

            // Create main histogram for all scores to get the max height
            const allScoresTrace = {
                x: scores,
                type: 'histogram',
                name: 'All Parcels',
                marker: {
                    color: '#ff6666',
                    line: {
                        color: 'rgba(200,200,200,0.3)',
                        width: 1
                    }
                },
                nbinsx: 50,
                opacity: 0.7
            };

            const traces = [allScoresTrace];

            // Calculate the expected maximum height for reference bars (1/4 of plot height)
            // We'll estimate this based on the data distribution
            const binCount = Math.ceil(scores.length / 50); // Rough estimate of max bin height
            const referenceBarHeight = binCount * 0.25; // 1/4 of expected max height

            // Add selected area bars and arrows if available
            if (selectedAreaScores.length > 0) {
                const selectedAreaMean = selectedAreaScores.reduce((a, b) => a + b, 0) / selectedAreaScores.length;
                const selectedAreaMin = Math.min(...selectedAreaScores);
                const selectedAreaMax = Math.max(...selectedAreaScores);
                
                // Add dotted bars at min and max (1/4 height)
                traces.push({
                    x: [selectedAreaMin, selectedAreaMin],
                    y: [0, referenceBarHeight],
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        color: '#ffff00',
                        width: 3,
                        dash: 'dot'
                    },
                    name: `Selected Area Min: ${selectedAreaMin.toFixed(3)}`,
                    showlegend: true
                });

                traces.push({
                    x: [selectedAreaMax, selectedAreaMax],
                    y: [0, referenceBarHeight],
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        color: '#ffff00',
                        width: 3,
                        dash: 'dot'
                    },
                    name: `Selected Area Max: ${selectedAreaMax.toFixed(3)}`,
                    showlegend: true
                });

                // Add solid bar at mean (1/4 height)
                traces.push({
                    x: [selectedAreaMean, selectedAreaMean],
                    y: [0, referenceBarHeight],
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        color: '#ffff00',
                        width: 3
                    },
                    name: `Selected Area Mean: ${selectedAreaMean.toFixed(3)}`,
                    showlegend: true
                });
            }

            const layout = {
                title: 'Calculated Risk Score Distribution',
                paper_bgcolor: '#1a1a1a',
                plot_bgcolor: '#1a1a1a',
                font: {
                    color: '#fff'
                },
                xaxis: {
                    title: 'Score',
                    gridcolor: 'rgba(255,255,255,0.1)',
                    zerolinecolor: 'rgba(255,255,255,0.1)'
                },
                yaxis: {
                    title: 'Count',
                    gridcolor: 'rgba(255,255,255,0.1)',
                    zerolinecolor: 'rgba(255,255,255,0.1)'
                },
                showlegend: true,
                legend: {
                    font: {
                        color: '#fff'
                    },
                    y: 0.95,
                    x: 0.02
                },
                bargap: 0,
                displayModeBar: false,
                margin: {
                    l: 50,
                    r: 20,
                    t: 50,
                    b: 50
                },
                height: 600,
                annotations: []
            };

            // Add statistics annotation
            let statsText = `All Parcels:<br>Min: ${allScoresMin.toFixed(3)}<br>Max: ${allScoresMax.toFixed(3)}<br>Mean: ${allScoresMean.toFixed(3)}<br>Std: ${allScoresStd.toFixed(3)}<br>Count: ${scores.length}<br><br>Top N Parcels:<br>Min: ${selectedScoresMin.toFixed(3)}<br>Max: ${selectedScoresMax.toFixed(3)}<br>Mean: ${selectedScoresMean.toFixed(3)}<br>Std: ${selectedScoresStd.toFixed(3)}<br>Count: ${selectedScores.length}`;
            
            if (selectedAreaScores.length > 0) {
                const selectedAreaMean = selectedAreaScores.reduce((a, b) => a + b, 0) / selectedAreaScores.length;
                const selectedAreaMin = Math.min(...selectedAreaScores);
                const selectedAreaMax = Math.max(...selectedAreaScores);
                const selectedAreaStd = Math.sqrt(selectedAreaScores.reduce((a, b) => a + Math.pow(b - selectedAreaMean, 2), 0) / selectedAreaScores.length);
                statsText += `<br><br>Selected Area:<br>Min: ${selectedAreaMin.toFixed(3)}<br>Max: ${selectedAreaMax.toFixed(3)}<br>Mean: ${selectedAreaMean.toFixed(3)}<br>Std: ${selectedAreaStd.toFixed(3)}<br>Count: ${selectedAreaScores.length}`;
            }

            layout.annotations.push({
                x: 0.02,
                y: 0.02,
                xref: 'paper',
                yref: 'paper',
                text: statsText,
                showarrow: false,
                font: {
                    color: '#fff',
                    size: 12
                },
                bgcolor: 'rgba(0,0,0,0.5)',
                bordercolor: 'rgba(255,255,255,0.3)',
                borderwidth: 1,
                borderpad: 4,
                xanchor: 'left',
                yanchor: 'bottom'
            });

            // Add single arrow for top parcels (blue arrow)
            const maxY = referenceBarHeight * 4; // Estimate max plot height
            const arrowY = maxY * 0.9; // Position arrows near top
            
            // Add single arrow for Top Parcels at the midpoint of selected scores
            if (selectedScores.length > 0) {
                const topParcelsScore = selectedScores[Math.floor(selectedScores.length / 2)];
                layout.annotations.push({
                    x: topParcelsScore,
                    y: arrowY,
                    text: 'Top Parcels',
                    showarrow: true,
                    arrowhead: 2,
                    arrowsize: 1,
                    arrowwidth: 2,
                    arrowcolor: '#0066ff',
                    font: {
                        color: '#0066ff',
                        size: 12
                    },
                    xanchor: 'center',
                    yanchor: 'bottom'
                });
            }

            // Add arrows for selected area scores (yellow arrows for min, mean, max)
            if (selectedAreaScores.length > 0) {
                const selectedAreaMean = selectedAreaScores.reduce((a, b) => a + b, 0) / selectedAreaScores.length;
                const selectedAreaMin = Math.min(...selectedAreaScores);
                const selectedAreaMax = Math.max(...selectedAreaScores);
                
                const yellowArrowY = arrowY * 0.7;
                
                // Min arrow
                layout.annotations.push({
                    x: selectedAreaMin,
                    y: yellowArrowY,
                    text: 'Min',
                    showarrow: true,
                    arrowhead: 2,
                    arrowsize: 1,
                    arrowwidth: 2,
                    arrowcolor: '#ffff00',
                    font: {
                        color: '#ffff00',
                        size: 12
                    },
                    xanchor: 'center',
                    yanchor: 'bottom'
                });
                
                // Mean arrow
                layout.annotations.push({
                    x: selectedAreaMean,
                    y: yellowArrowY,
                    text: 'Mean',
                    showarrow: true,
                    arrowhead: 2,
                    arrowsize: 1,
                    arrowwidth: 2,
                    arrowcolor: '#ffff00',
                    font: {
                        color: '#ffff00',
                        size: 12
                    },
                    xanchor: 'center',
                    yanchor: 'bottom'
                });
                
                // Max arrow
                layout.annotations.push({
                    x: selectedAreaMax,
                    y: yellowArrowY,
                    text: 'Max',
                    showarrow: true,
                    arrowhead: 2,
                    arrowsize: 1,
                    arrowwidth: 2,
                    arrowcolor: '#ffff00',
                    font: {
                        color: '#ffff00',
                        size: 12
                    },
                    xanchor: 'center',
                    yanchor: 'bottom'
                });
            }

            Plotly.newPlot('dist-plot', traces, layout);
            modal.style.display = "block";
        });

        function refreshScoreDistributionPlot() {
            if (!currentData) return;

            const scores = currentData.features.map(f => f.properties.score);
            const selectedScores = currentData.features
                .filter(f => f.properties.top500)
                .map(f => f.properties.score);

            // Get selected area scores if available
            let selectedAreaScores = [];
            if (selectedParcels && selectedParcels.length > 0) {
                selectedAreaScores = selectedParcels.map(f => f.properties.score);
            }

            // Calculate statistics for all scores
            const allScoresMean = scores.reduce((a, b) => a + b, 0) / scores.length;
            const allScoresMin = Math.min(...scores);
            const allScoresMax = Math.max(...scores);
            const allScoresStd = Math.sqrt(scores.reduce((a, b) => a + Math.pow(b - allScoresMean, 2), 0) / scores.length);

            // Calculate statistics for selected scores
            const selectedScoresMean = selectedScores.reduce((a, b) => a + b, 0) / selectedScores.length;
            const selectedScoresMin = Math.min(...selectedScores);
            const selectedScoresMax = Math.max(...selectedScores);
            const selectedScoresStd = Math.sqrt(selectedScores.reduce((a, b) => a + Math.pow(b - selectedScoresMean, 2), 0) / selectedScores.length);

            // Create main histogram for all scores to get the max height
            const allScoresTrace = {
                x: scores,
                type: 'histogram',
                name: 'All Parcels',
                marker: {
                    color: '#ff6666',
                    line: {
                        color: 'rgba(200,200,200,0.3)',
                        width: 1
                    }
                },
                nbinsx: 50,
                opacity: 0.7
            };

            const traces = [allScoresTrace];

            // Calculate the expected maximum height for reference bars (1/4 of plot height)
            const binCount = Math.ceil(scores.length / 50);
            const referenceBarHeight = binCount * 0.25;

            // Add selected area bars and arrows if available
            if (selectedAreaScores.length > 0) {
                const selectedAreaMean = selectedAreaScores.reduce((a, b) => a + b, 0) / selectedAreaScores.length;
                const selectedAreaMin = Math.min(...selectedAreaScores);
                const selectedAreaMax = Math.max(...selectedAreaScores);
                
                // Add dotted bars at min and max (1/4 height)
                traces.push({
                    x: [selectedAreaMin, selectedAreaMin],
                    y: [0, referenceBarHeight],
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        color: '#ffff00',
                        width: 3,
                        dash: 'dot'
                    },
                    name: `Selected Area Min: ${selectedAreaMin.toFixed(3)}`,
                    showlegend: true
                });

                traces.push({
                    x: [selectedAreaMax, selectedAreaMax],
                    y: [0, referenceBarHeight],
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        color: '#ffff00',
                        width: 3,
                        dash: 'dot'
                    },
                    name: `Selected Area Max: ${selectedAreaMax.toFixed(3)}`,
                    showlegend: true
                });

                // Add solid bar at mean (1/4 height)
                traces.push({
                    x: [selectedAreaMean, selectedAreaMean],
                    y: [0, referenceBarHeight],
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        color: '#ffff00',
                        width: 3
                    },
                    name: `Selected Area Mean: ${selectedAreaMean.toFixed(3)}`,
                    showlegend: true
                });
            }

            const layout = {
                title: 'Calculated Risk Score Distribution (Auto-Updated)',
                paper_bgcolor: '#1a1a1a',
                plot_bgcolor: '#1a1a1a',
                font: {
                    color: '#fff'
                },
                xaxis: {
                    title: 'Score',
                    gridcolor: 'rgba(255,255,255,0.1)',
                    zerolinecolor: 'rgba(255,255,255,0.1)'
                },
                yaxis: {
                    title: 'Count',
                    gridcolor: 'rgba(255,255,255,0.1)',
                    zerolinecolor: 'rgba(255,255,255,0.1)'
                },
                showlegend: true,
                legend: {
                    font: {
                        color: '#fff'
                    },
                    y: 0.95,
                    x: 0.02
                },
                bargap: 0,
                displayModeBar: false,
                margin: {
                    l: 50,
                    r: 20,
                    t: 50,
                    b: 50
                },
                height: 600,
                annotations: []
            };

            // Add statistics annotation
            let statsText = `All Parcels:<br>Min: ${allScoresMin.toFixed(3)}<br>Max: ${allScoresMax.toFixed(3)}<br>Mean: ${allScoresMean.toFixed(3)}<br>Std: ${allScoresStd.toFixed(3)}<br>Count: ${scores.length}<br><br>Top N Parcels:<br>Min: ${selectedScoresMin.toFixed(3)}<br>Max: ${selectedScoresMax.toFixed(3)}<br>Mean: ${selectedScoresMean.toFixed(3)}<br>Std: ${selectedScoresStd.toFixed(3)}<br>Count: ${selectedScores.length}`;
            
            if (selectedAreaScores.length > 0) {
                const selectedAreaMean = selectedAreaScores.reduce((a, b) => a + b, 0) / selectedAreaScores.length;
                const selectedAreaMin = Math.min(...selectedAreaScores);
                const selectedAreaMax = Math.max(...selectedAreaScores);
                const selectedAreaStd = Math.sqrt(selectedAreaScores.reduce((a, b) => a + Math.pow(b - selectedAreaMean, 2), 0) / selectedAreaScores.length);
                statsText += `<br><br>Selected Area:<br>Min: ${selectedAreaMin.toFixed(3)}<br>Max: ${selectedAreaMax.toFixed(3)}<br>Mean: ${selectedAreaMean.toFixed(3)}<br>Std: ${selectedAreaStd.toFixed(3)}<br>Count: ${selectedAreaScores.length}`;
            }

            layout.annotations.push({
                x: 0.02,
                y: 0.02,
                xref: 'paper',
                yref: 'paper',
                text: statsText,
                showarrow: false,
                font: {
                    color: '#fff',
                    size: 12
                },
                bgcolor: 'rgba(0,0,0,0.5)',
                bordercolor: 'rgba(255,255,255,0.3)',
                borderwidth: 1,
                borderpad: 4,
                xanchor: 'left',
                yanchor: 'bottom'
            });

            // Add single arrow for top parcels (blue arrow)
            const maxY = referenceBarHeight * 4;
            const arrowY = maxY * 0.9;
            
            // Add single arrow for Top Parcels at the midpoint of selected scores
            if (selectedScores.length > 0) {
                const topParcelsScore = selectedScores[Math.floor(selectedScores.length / 2)];
                layout.annotations.push({
                    x: topParcelsScore,
                    y: arrowY,
                    text: 'Top Parcels',
                    showarrow: true,
                    arrowhead: 2,
                    arrowsize: 1,
                    arrowwidth: 2,
                    arrowcolor: '#0066ff',
                    font: {
                        color: '#0066ff',
                        size: 12
                    },
                    xanchor: 'center',
                    yanchor: 'bottom'
                });
            }

            // Add arrows for selected area scores (yellow arrows for min, mean, max)
            if (selectedAreaScores.length > 0) {
                const selectedAreaMean = selectedAreaScores.reduce((a, b) => a + b, 0) / selectedAreaScores.length;
                const selectedAreaMin = Math.min(...selectedAreaScores);
                const selectedAreaMax = Math.max(...selectedAreaScores);
                
                const yellowArrowY = arrowY * 0.7;
                
                // Min arrow
                layout.annotations.push({
                    x: selectedAreaMin,
                    y: yellowArrowY,
                    text: 'Min',
                    showarrow: true,
                    arrowhead: 2,
                    arrowsize: 1,
                    arrowwidth: 2,
                    arrowcolor: '#ffff00',
                    font: {
                        color: '#ffff00',
                        size: 12
                    },
                    xanchor: 'center',
                    yanchor: 'bottom'
                });
                
                // Mean arrow
                layout.annotations.push({
                    x: selectedAreaMean,
                    y: yellowArrowY,
                    text: 'Mean',
                    showarrow: true,
                    arrowhead: 2,
                    arrowsize: 1,
                    arrowwidth: 2,
                    arrowcolor: '#ffff00',
                    font: {
                        color: '#ffff00',
                        size: 12
                    },
                    xanchor: 'center',
                    yanchor: 'bottom'
                });
                
                // Max arrow
                layout.annotations.push({
                    x: selectedAreaMax,
                    y: yellowArrowY,
                    text: 'Max',
                    showarrow: true,
                    arrowhead: 2,
                    arrowsize: 1,
                    arrowwidth: 2,
                    arrowcolor: '#ffff00',
                    font: {
                        color: '#ffff00',
                        size: 12
                    },
                    xanchor: 'center',
                    yanchor: 'bottom'
                });
            }

            Plotly.newPlot('dist-plot', traces, layout);
        }

        // Layer toggles
        document.querySelectorAll('.layer-toggle[data-layer="dark"], .layer-toggle[data-layer="light"], .layer-toggle[data-layer="satellite"]').forEach(toggle => {
            toggle.addEventListener('change', (e) => {
                if (e.target.checked) {
                    document.querySelectorAll('.layer-toggle[data-layer="dark"], .layer-toggle[data-layer="light"], .layer-toggle[data-layer="satellite"]').forEach(t => {
                        if (t !== e.target) t.checked = false;
                    });
                    
                    const styleMap = {
                        'dark': 'mapbox://styles/mapbox/dark-v11',
                        'light': 'mapbox://styles/mapbox/light-v11',
                        'satellite': 'mapbox://styles/mapbox/satellite-streets-v12'
                    };
                    map.setStyle(styleMap[e.target.dataset.layer]);
                    
                    map.once('style.load', () => {
                        initializeLayers();
                    });
                }
            });
        });
        
        document.querySelectorAll('.layer-toggle[data-layer]:not([data-layer="dark"]):not([data-layer="light"]):not([data-layer="satellite"])').forEach(toggle => {
            toggle.addEventListener('change', (e) => {
                const layerId = e.target.dataset.layer;
                const visibility = e.target.checked ? 'visible' : 'none';
                
                if (layerId === 'parcels') {
                    if (map.getLayer('parcels-fill')) {
                        map.setLayoutProperty('parcels-fill', 'visibility', visibility);
                    }
                    if (map.getLayer('parcels-top500')) {
                        map.setLayoutProperty('parcels-top500', 'visibility', visibility);
                    }
                } else if (layerId === 'burnscars') {
                    if (map.getLayer('burnscars')) {
                        map.setLayoutProperty('burnscars', 'visibility', visibility);
                    }
                    if (map.getLayer('burnscars-outline')) {
                        map.setLayoutProperty('burnscars-outline', 'visibility', visibility);
                    }
                } else if (map.getLayer(layerId)) {
                    map.setLayoutProperty(layerId, 'visibility', visibility);
                }
            });
        });

        // Modal controls
        closeModal.onclick = function() {
            modal.style.display = "none";
        }
        
        // Close solution modal
        document.getElementById('close-solution-modal').addEventListener('click', () => {
            document.getElementById('solution-modal').style.display = 'none';
        });

        // Show correlation matrix
        document.getElementById('show-correlation-matrix').addEventListener('click', () => {
            window.plottingManager.showCorrelationMatrix();
        });

        // Close correlation modal
        document.getElementById('close-correlation-modal').addEventListener('click', () => {
            document.getElementById('correlation-modal').style.display = 'none';
        });
        
        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = "none";
            }
            // Close solution modal when clicking outside of it
            const solutionModal = document.getElementById('solution-modal');
            if (event.target === solutionModal) {
                solutionModal.style.display = 'none';
            }
            // Close correlation modal when clicking outside of it
            const correlationModal = document.getElementById('correlation-modal');
            if (event.target === correlationModal) {
                correlationModal.style.display = 'none';
            }
        }

        // Measure tool
        measureButton.addEventListener('click', () => {
            measureMode = !measureMode;
            measureButton.textContent = measureMode ? 'Cancel Measurement' : 'Measure Distance';
            
            if (!measureMode) {
                exitMeasureMode();
            }
        });

        // Map event handlers
        map.on('draw.create', (e) => {
            const selection = e.features[0];
            
            // Check if this is a subset area selection
            if (document.getElementById('subset-rectangle').dataset.mode === 'subset' || 
                document.getElementById('subset-lasso').dataset.mode === 'subset') {
                subsetArea = selection.geometry;
                document.getElementById('filter-parcels').disabled = false;
                
                // Reset modes
                document.getElementById('subset-rectangle').dataset.mode = '';
                document.getElementById('subset-lasso').dataset.mode = '';
            } 
            // Check if this is multi-area selection for weight inference
            else if (isAddingSelection) {
                const drawMode = draw.getMode();
                const selectionType = drawMode === 'draw_rectangle' ? 'rectangle' : 'lasso';
                
                // Add to selection areas with the feature ID for tracking
                const featureId = selection.id;
                addSelectionArea(selection.geometry, selectionType, featureId);
                
                // Keep the drawn feature visible (don't delete)
                // Reset selection mode to simple_select so user can draw more
                isAddingSelection = false;
                draw.changeMode('simple_select');
                
                console.log(`Added ${selectionType} to selection areas. Total: ${selectionAreas.length}`);
            } 
            // Legacy single selection (kept for compatibility) - updated for vector tiles
            else {
                // Regular single selection for weight inference (legacy mode)
                document.getElementById('infer-weights').disabled = false;
                
                console.log('VECTOR TILES: Legacy selection mode - using queryRenderedFeatures...');
                
                if (window.turf) {
                    // Use queryRenderedFeatures for vector tile selection
                    const bbox = window.turf.bbox(selection);
                    const pixelBounds = [
                        map.project([bbox[0], bbox[1]]),
                        map.project([bbox[2], bbox[3]])
                    ];
                    
                    const selectedFeatures = map.queryRenderedFeatures(
                        pixelBounds,
                        { layers: ['parcels-fill'] }
                    );
                    
                    // Filter geometrically and map to attribute data
                    selectedParcels = selectedFeatures
                        .filter(feature => window.turf.booleanIntersects(feature, selection))
                        .map(feature => {
                            const parcelId = feature.properties.parcel_id || feature.id;
                            const attributes = window.fireRiskScoring.getAttributesByParcelId(parcelId);
                            return {
                                type: "Feature",
                                geometry: null, // Don't need geometry for weight inference
                                properties: attributes
                            };
                        })
                        .filter(feature => feature.properties); // Remove any missing attributes
                    
                    const selectedCount = selectedParcels.length;
                    const totalRisk = selectedParcels.reduce((sum, f) => sum + (f.properties.score || 0), 0);
                    const avgRisk = selectedCount > 0 ? totalRisk / selectedCount : 0;
                    
                    console.log(`VECTOR TILES: Legacy selection found ${selectedCount} parcels`);
                    
                    document.getElementById('selected-parcels').textContent = selectedCount.toLocaleString();
                    document.getElementById('total-risk').textContent = totalRisk.toFixed(2);
                    document.getElementById('avg-risk').textContent = avgRisk.toFixed(2);
                }
            }
        });

        function resetInferWeightsUI() {
            document.getElementById('infer-weights').disabled = true;
            document.getElementById('download-lp-btn').disabled = true;
            document.getElementById('download-txt-btn').disabled = true;
            document.getElementById('view-solution-btn').disabled = true;
            currentOptimizationSession = null;
        }

        map.on('draw.delete', () => {
            selectedParcels = [];
            resetInferWeightsUI();
            
            // If no shapes remain, disable filter button and clear subset area
            const features = draw.getAll().features;
            if (features.length === 0) {
                document.getElementById('filter-parcels').disabled = true;
                subsetArea = null;
                document.getElementById('subset-indicator').style.display = 'none';
            }
        });

        map.on('click', (e) => {
            if (measureMode) {
                measurePoints.push([e.lngLat.lng, e.lngLat.lat]);

                if (measurePoints.length === 1) {
                    if (map.getSource('measure-line')) {
                        map.removeLayer('measure-line');
                        map.removeSource('measure-line');
                    }
                    map.addSource('measure-line', {
                        type: 'geojson',
                        data: {
                            type: 'Feature',
                            properties: {},
                            geometry: {
                                type: 'LineString',
                                coordinates: measurePoints
                            }
                        }
                    });
                    map.addLayer({
                        id: 'measure-line',
                        type: 'line',
                        source: 'measure-line',
                        layout: {
                            'line-cap': 'round',
                            'line-join': 'round'
                        },
                        paint: {
                            'line-color': '#fff',
                            'line-width': 2,
                            'line-dasharray': [2, 2]
                        }
                    });
                } else {
                    const line = {
                        type: 'Feature',
                        properties: {},
                        geometry: {
                            type: 'LineString',
                            coordinates: measurePoints
                        }
                    };
                    map.getSource('measure-line').setData(line);

                    const distance = turf.length(line) * 3280.84;
                    document.getElementById('distance').textContent = `Total distance: ${distance.toFixed(0)} ft`;
                }
            }
        });

        map.on('mousemove', (e) => {
            if (!measureMode || measurePoints.length === 0) return;

            const line = {
                type: 'Feature',
                properties: {},
                geometry: {
                    type: 'LineString',
                    coordinates: [...measurePoints, [e.lngLat.lng, e.lngLat.lat]]
                }
            };
            map.getSource('measure-line').setData(line);

            if (measurePoints.length > 0) {
                const distance = turf.length(line) * 3280.84;
                document.getElementById('distance').textContent = `Total distance: ${distance.toFixed(0)} ft`;
            }
        });

        map.on('contextmenu', (e) => {
            if (!measureMode) return;
            e.preventDefault();
            exitMeasureMode();
        });

        map.on('click', 'parcels-fill', (e) => {
            if (measureMode || draw.getMode() === 'draw_rectangle' || draw.getMode() === 'draw_lasso') {
                return;
            }
            
            console.log('VECTOR TILES: Parcel clicked, looking up attributes...');
            
            const parcelId = e.features[0].properties.parcel_id || e.features[0].id;
            const attributes = window.fireRiskScoring.getAttributesByParcelId(parcelId);
            
            if (attributes) {
                console.log(`VECTOR TILES: Found attributes for parcel ${parcelId}`);
                new mapboxgl.Popup()
                    .setLngLat(e.lngLat)
                    .setHTML(createPopupContent(attributes))
                    .addTo(map);
            } else {
                console.warn(`VECTOR TILES: No attributes found for parcel ${parcelId}`);
                new mapboxgl.Popup()
                    .setLngLat(e.lngLat)
                    .setHTML(`<div>Parcel ID: ${parcelId}<br/>No attribute data available</div>`)
                    .addTo(map);
            }
        });
        
        map.on('mouseenter', 'parcels-fill', () => {
            if (draw.getMode() !== 'draw_rectangle' && draw.getMode() !== 'draw_lasso' && !measureMode) {
                map.getCanvas().style.cursor = 'pointer';
            }
        });
        
        map.on('mouseleave', 'parcels-fill', () => {
            if (draw.getMode() !== 'draw_rectangle' && draw.getMode() !== 'draw_lasso' && !measureMode) {
                map.getCanvas().style.cursor = '';
            }
        });

        // Burnscars click handler
        map.on('click', 'burnscars', (e) => {
            if (measureMode || draw.getMode() === 'draw_rectangle' || draw.getMode() === 'draw_lasso') {
                return;
            }
            
            const props = e.features[0].properties;
            new mapboxgl.Popup()
                .setLngLat(e.lngLat)
                .setHTML(createBurnscarPopupContent(props))
                .addTo(map);
        });
        
        map.on('mouseenter', 'burnscars', () => {
            if (draw.getMode() !== 'draw_rectangle' && draw.getMode() !== 'draw_lasso' && !measureMode) {
                map.getCanvas().style.cursor = 'pointer';
            }
        });
        
        map.on('mouseleave', 'burnscars', () => {
            if (draw.getMode() !== 'draw_rectangle' && draw.getMode() !== 'draw_lasso' && !measureMode) {
                map.getCanvas().style.cursor = '';
            }
        });

        // Initialize layers function
        function initializeLayers() {
            console.log('VECTOR TILES: Initializing layers with vector tile source...');
            
            // Add vector tile source for parcels
            map.addSource('parcel-tiles', {
                type: 'vector',
                url: 'mapbox://theo1158.d77x09xc'
            });
            
            // Global data object for attribute lookup in paint expressions
            window.parcelScores = {}; // Will be updated by updateMap()
            window.top500ParcelIds = []; // Will be updated by updateMap()
            
            map.addLayer({
                id: 'parcels-fill',
                type: 'fill',
                source: 'parcel-tiles',
                'source-layer': 'parcels_for_mapbox-2wpi1y', // Actual layer name from Mapbox tileset
                paint: {
                    'fill-color': [
                        'case',
                        ['has', ['to-string', ['get', 'parcel_id']], ['literal', window.parcelScores]],
                        [
                            'interpolate',
                            ['linear'],
                            ['get', ['to-string', ['get', 'parcel_id']], ['literal', window.parcelScores]],
                            0, '#ffffff',
                            0.2, '#ffdddd',
                            0.4, '#ffaaaa',
                            0.6, '#ff6666',
                            0.8, '#ff3333',
                            1, '#990000'
                        ],
                        '#eeeeee' // Default color for parcels without scores
                    ],
                    'fill-opacity': 0.8
                }
            });
            
            map.addLayer({
                id: 'parcels-boundary',
                type: 'line',
                source: 'parcel-tiles',
                'source-layer': 'parcels_for_mapbox-2wpi1y',
                minzoom: 14,
                paint: {
                    'line-color': '#ffffff',
                    'line-width': 0.5,
                    'line-opacity': 0.3
                }
            });
            
            map.addLayer({
                id: 'parcels-top500',
                type: 'line',
                source: 'parcel-tiles',
                'source-layer': 'parcels_for_mapbox-2wpi1y',
                filter: ['in', ['to-string', ['get', 'parcel_id']], ['literal', window.top500ParcelIds]],
                paint: {
                    'line-color': '#0066ff',
                    'line-width': 2
                }
            });
            
            console.log('VECTOR TILES: Parcel layers initialized with vector tile source');
            
            const auxiliaryLayers = [
                {
                    id: 'agricultural',
                    type: 'fill',
                    paint: {
                        'fill-color': '#00ff00',
                        'fill-opacity': 0.5
                    }
                },
                {
                    id: 'fuelbreaks',
                    type: 'fill',
                    paint: {
                        'fill-color': '#00ff00',
                        'fill-opacity': 0.5
                    }
                },
                {
                    id: 'wui',
                    type: 'fill',
                    paint: {
                        'fill-color': '#0066ff',
                        'fill-opacity': 0.5
                    }
                },
                {
                    id: 'hazard',
                    type: 'fill',
                    paint: {
                        'fill-color': '#ff9900',
                        'fill-opacity': 0.25
                    }
                },
                {
                    id: 'structures',
                    type: 'fill',
                    paint: {
                        'fill-color': '#000000',
                        'fill-opacity': 0.5
                    }
                },
                {
                    id: 'firewise',
                    type: 'line',
                    paint: {
                        'line-color': '#ff9900',
                        'line-width': 2
                    }
                },
                {
                    id: 'burnscars',
                    type: 'fill',
                    paint: {
                        'fill-color': '#ffcc99',
                        'fill-opacity': 0.3,
                        'fill-outline-color': '#cc7722'
                    }
                }
            ];

            auxiliaryLayers.forEach(layer => {
                map.addSource(layer.id, {
                    type: 'geojson',
                    data: { type: 'FeatureCollection', features: [] }
                });
                
                map.addLayer({
                    id: layer.id,
                    type: layer.type,
                    source: layer.id,
                    layout: { 'visibility': 'none' },
                    paint: layer.paint
                });
                
                // Add outline layer for burn scars
                if (layer.id === 'burnscars') {
                    map.addLayer({
                        id: 'burnscars-outline',
                        type: 'line',
                        source: layer.id,
                        layout: { 'visibility': 'none' },
                        paint: {
                            'line-color': '#cc7722',
                            'line-width': 1.0
                        }
                    });
                }
                
                loadLayer(layer.id);
            });

            if (currentData) {
                updateMap();
            }
            // Note: updateScores(true) will be called by map.on('load') to avoid duplicate initialization
        }

        // Map load
        map.on('load', () => {
            console.log('🚀 Map loaded - starting application initialization...');
            initializeLayers();
            normalizeWeights();
            updateMaxParcels();
            updateSelectionCount(); // Initialize multi-area selection UI
            updateDistributionButtons(); // Initialize distribution buttons with correct score type
            console.log('🎯 Starting single initial data load and client-side calculation...');
            updateScores(true);  // Single initial load and client-side calculation
            
            document.querySelectorAll('input[type="range"]').forEach(slider => {
                updateSliderFill(slider);
            });
            console.log('✅ Application initialization complete');
        });



        // Global keyboard handler
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Don't handle Escape if we're in drawing mode - let the drawing tool handle it
                const currentMode = draw.getMode();
                if (currentMode === 'draw_lasso' || currentMode === 'draw_rectangle') {
                    return;
                }
                
                if (measureMode) {
                    exitMeasureMode();
                }
                // Close solution modal if open
                const solutionModal = document.getElementById('solution-modal');
                if (solutionModal.style.display === 'block') {
                    solutionModal.style.display = 'none';
                }
            }
        });

        // Variable enable/disable functionality
        function toggleVariable(variableId, enabled) {
            const container = document.querySelector(`[data-variable="${variableId}"]`);
            const controls = container.querySelector('.variable-controls');
            const slider = document.getElementById(variableId);
            const valueDisplay = document.getElementById(`${variableId}-value`);
            
            if (enabled) {
                // Enable variable
                container.classList.remove('disabled');
                controls.classList.remove('collapsed');
                controls.classList.add('expanded');
                
                // Restore the previous value if it exists
                const previousValue = slider.dataset.previousValue || slider.value;
                slider.value = previousValue;
                slider.classList.remove('disabled');
                updateSliderFill(slider);
            } else {
                // Disable variable
                container.classList.add('disabled');
                controls.classList.remove('expanded');
                controls.classList.add('collapsed');
                
                // Store the current value before setting to 0
                slider.dataset.previousValue = slider.value;
                slider.value = 0;
                slider.classList.add('disabled');
                valueDisplay.textContent = '0%';
            }
            
            // Always renormalize weights
            normalizeWeights();
            
            // Check if there's an active weight inference selection
            const inferWeightsBtn = document.getElementById('infer-weights');
            const hasActiveSelection = !inferWeightsBtn.disabled;
            
            if (hasActiveSelection && draw.getAll().features.length > 0) {
                // Automatically rerun weight inference with updated exclude settings
                console.log('Rerunning weight inference due to variable enable/disable change');
                inferWeightsBtn.click();
            } else {
                // No active weight inference selection, just update scores normally
                updateScores(false);  // Weight change, not filter change
            }
        }

        // Add event listeners for variable enable checkboxes
        document.querySelectorAll('.variable-enable-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', (e) => {
                const variableId = e.target.id.replace('enable-', '');
                toggleVariable(variableId, e.target.checked);
            });
        });

        // Panel toggle functionality
        function togglePanel() {
            const panel = document.getElementById('control-panel');
            const toggle = document.getElementById('panel-toggle');
            
            if (panel.classList.contains('collapsed')) {
                // Show panel
                panel.classList.remove('collapsed');
                toggle.classList.remove('show');
            } else {
                // Hide panel
                panel.classList.add('collapsed');
                toggle.classList.add('show');
            }
        }

        // Load Turf.js
        const script = document.createElement('script');
        script.src = 'https://unpkg.com/@turf/turf@6/turf.min.js';
        document.head.appendChild(script);
    </script>
</body>
</html>